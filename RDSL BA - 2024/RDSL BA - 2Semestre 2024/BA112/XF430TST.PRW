#include "PROTHEUS.CH"
#include "fileio.ch"
#include "FINA430.CH"
#include "FWMVCDEF.CH"

Static lFWCodFil  := .T.
Static _oFina430  As Object
Static _lExistTcb As Logical
Static __lVldExtC As Logical

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FinA430  ³ Autor ³ Pilar Sanchez         ³ Data ³ 26/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorno da comunicação banc ria - Pagar                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FinA430(nPosArotina)                                       ³±±
±±³			 ³ nPosArotina - Recebe a posicao do array aRotina para       ³±±
±±³          ³ executar a funcao escolhida                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³  Motivo da Alteracao                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³JBS-Jailton ³26/08/13³ Correcao na gravacao do campo E5_BENEF          ³±±
±±³            ³        ³                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function XF430TST(nPosAuto,aParam)
Local lPanelFin := IsPanelFin()
Local lOk		:= .F.
Local aSays 	:= {}
Local aButtons  := {}
Local cPerg		:= "AFI430"
Local nI		:= NIL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define o cabecalho da tela de baixas ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE cCadastro := OemToAnsi( STR0006 )  //"Retorno CNAB Pagar"
Private aTit
Private cTipoBx  := ""
Private nVlrCnab := 0
Private lMVCNBImpg := GetNewPar("MV_CNBIMPG",.F.)

// Retorno Automatico via Job
// parametro que controla execucao via Job utilizado para pontos de entrada que nao tem como passar o parametro
Private lExecJob := ExecSchedule()

DEFAULT aParam := {}	//Modelo conteudo do array {{'MV_PAR01',Valor},{'MV_PAR02',Valor},{'MV_PARn',ValorN}}

If !lExecJob .And. GetHlpLGPD({"A2_NOME","A6_COD"})
	Return .F.
Endif

// Retorno Automatico via Job
if lExecJob
	nPosAuto := 1 // Envia arquivo
Endif

If _lExistTcb == Nil
	_lExistTcb := FindFunction("FINI230O") .and. AliasInDic("FWO") .and. SA6->(FieldPos("A6_TCB")) > 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as perguntas selecionadas                 ³
//³                                                    ³
//³ Parametros                                         ³
//³                                                    ³
//³ MV_PAR01: Mostra Lanc. Contab  ? Sim Nao           ³
//³ MV_PAR02: Aglutina Lanc. Contab? Sim Nao           ³
//³ MV_PAR03: Arquivo de Entrada   ?                   ³
//³ MV_PAR04: Arquivo de Config    ?                   ³
//³ MV_PAR05: Banco                ?                   ³
//³ MV_PAR06: Agencia              ?                   ³
//³ MV_PAR07: Conta                ?                   ³
//³ MV_PAR08: SubConta             ?                   ³
//³ MV_PAR09: Contabiliza          ?                   ³
//³ MV_PAR10: Padrao Cnab          ? Modelo1 Modelo 2  ³
//³ MV_PAR11: Processa filiais     ? Modelo1 Modelo 2  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

A460FSA2()	//Aplica Filtro na tabela de Fornecedores (SA2)

If lPanelFin .and. ! lExecJob  // Retorno Automatico via Job
	lPergunte := PergInPanel(cPerg,.T.)
Else
	if lExecJob    // Retorno Automatico via Job
		If !EMPTY(aparam)
			For nI := 1 To LEN(aParam)
				If 'MV_PAR' $ UPPER(aParam[nI,1])
					&(aParam[nI,1]) := aParam[nI,2]
				EndIf
			Next nI
		Else
			Pergunte(cPerg,.F.,Nil,Nil,Nil,.F.)  // carrega as perguntas que foram atualizadas pelo FINA435
		EndIf

		lPergunte := .T.
	Else
		lPergunte := pergunte(cPerg,.T.)
	Endif
Endif

If lPergunte
	MV_PAR03 := UPPER(MV_PAR03)

	dbSelectArea("SE2")
	dbSetOrder(1)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o log de processamento                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogIni( aButtons )

	If nPosAuto <> Nil
		lOk := .T.
	Else
		aADD(aSays,STR0013)
		aADD(aSays,STR0014)
		If lPanelFin  //Chamado pelo Painel Financeiro
			aButtonTxt := {}
			If Len(aButtons) > 0
				AADD(aButtonTxt,{STR0002,STR0002,aButtons[1][3]}) // Visualizar
			Endif
			AADD(aButtonTxt,{STR0001,STR0001, {||Pergunte("AFI430",.T. )}}) // Parametros
			FaMyFormBatch(aSays,aButtonTxt,{||lOk:=.T.},{||lOk:=.F.})
		Else
			aADD(aButtons, { 5,.T.,{|| Pergunte("AFI430",.T. ) } } )
			aADD(aButtons, { 1,.T.,{|| lOk := .T.,FechaBatch()}} )
			aADD(aButtons, { 2,.T.,{|| FechaBatch() }} )
			FormBatch( cCadastro, aSays, aButtons ,,,535)
		EndIf
   Endif
	If lOk
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if lExecJob
			ProcLogAtu("INICIO",STR0016+" - "+STR0017+mv_par03) // "Retorno Bancario Automatico (Pagar)" # "Arquivo:"
		Else
			ProcLogAtu("INICIO")
		Endif

		U_xfa430gera("SE2", aParam)

		//- efetua exclusão do model - FINA080		
		If FindFunction("F080ClearM")
			F080ClearM()
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lExecJob
			ProcLogAtu("FIM",,STR0016+" - "+STR0017+mv_par03) // "Retorno Bancario Automatico (Pagar)" # "Arquivo:"
		Else
			ProcLogAtu("FIM")
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Recupera a Integridade dos dados                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE2")
	dbSetOrder(1)
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fA430Ger ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Comunicacao Bancaria - Retorno                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fA430Ger(cAlias)                                           ³±±
±±³          ³ cAlias - Alias corrente para executar a funcao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FinA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß 
*/
User Function xfa430gera(cAlias, aParamB)
PRIVATE cLotefin	:= Space(TamSX3("EE_LOTECP")[1])
PRIVATE nTotAbat	:= 0,cConta := " "
PRIVATE nHdlBco		:= 0,nHdlConf := 0,nSeq := 0 ,cMotBx := "DEB"
PRIVATE nValEstrang	:= 0
PRIVATE cMarca		:= GetMark()
PRIVATE aAC			:= { STR0004,STR0005 }  //"Abandona"###"Confirma"
PRIVATE nTotAGer	:= 0
PRIVATE VALOR		:= 0
PRIVATE ABATIMENTO	:= 0
Private nAcresc, nDecresc

DEFAULT aParamB := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para Tratamento baixa - Citibank³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("F430CIT")
	ExecBlock("F430CIT",.F.,.F.)
Endif

Processa({|lEnd| U_fa430Ger(cAlias, aParamB)})  // Chamada com regua

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha os Arquivos ASCII ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nHdlBco > 0
	FCLOSE(nHdlBco)
Endif

If nHdlConf > 0
	FCLOSE(nHdlConf)
Endif

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fA430Gera³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Comunicacao Bancaria - Retorno                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fA430Ger(cAlias)                                           ³±±
±±³          ³ cAlias - Alias corrente para executar a funcao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FinA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function fA430Ger(cAlias, aParamB)

	Local cPosNum,cPosData,cPosDesp,cPosDesc,cPosAbat,cPosPrin,cPosJuro,cPosMult,cPosForne
	Local cPosOcor,cPosTipo,cPosCgc, cRejeicao, cPosDebito, cPosRejei
	Local cChave430,cNumSe2,cChaveSe2
	Local cArqConf,cArqEnt,cPosNsNum
	Local cTabela    := "17",cPadrao,cLanca
	Local cFilOrig   := cFilAnt	// Salva a filial para garantir que nao seja alterada em customizacao
	Local xBuffer
	Local lPosNum    := .f., lPosData := .f.
	Local lPosDesp   := .f., lPosDesc := .f., lPosAbat := .f.
	Local lPosPrin   := .f., lPosJuro := .f., lPosMult := .f.
	Local lPosOcor   := .f., lPosTipo := .f., lMovAdto := .F.
	Local lPosNsNum  := .f., lPosForne:= .f., lPosRejei:= .f.
	Local lPosCgc    := .f., lPosdebito:=.f.
	Local lDesconto  := .F.
	Local lContabiliza := .F.
	Local lUmHelp    := .F.
	Local lCabec     := .f.
	Local lPadrao    := .f., lBaixou := .f., lHeader := .f.
	Local lF430VAR   := ExistBlock("F430VAR"),lF430Baixa := ExistBlock("F430BXA")
	Local lF430Rej   := ExistBlock("F430REJ"),lFa430Oco  := ExistBlock("FA430OCO")
	Local lFa430Se2  := ExistBlock("FA430SE2"),lFa430Pa  := ExistBlock("FA430PA")
	Local lFa430Fil  := Existblock("FA430FIL")
	Local lFA430LP	 := Existblock("FA430LP")
	Local lRet       := .T.
	Local nLidos,nLenNum,nLenData,nLenDesp,nLenDesc,nLenAbat,nLenForne,nLenRejei
	Local nLenPrin,nLenJuro,nLenMult,nLenOcor,nLenTipo,nLenCgc, nLenDebito,nLenNsNum
	Local nTotal     := 0,nPos,nPosEsp,nBloco := 0
	Local nSavRecno  := Recno()
	Local nTamForn   := Tamsx3("E2_FORNECE")[1]
	Local nTamOcor   := TamSx3("EB_REFBAN")[1]
	Local nTamEEOcor := 2
	Local aTabela    := {},aLeitura := {},aValores := {},aCampos := {}
	Local dDebito
	Local nTamPre	:= TamSX3("E1_PREFIXO")[1]
	Local nTamNum	:= TamSX3("E1_NUM")[1]
	Local nTamPar	:= TamSX3("E1_PARCELA")[1]
	Local nTamTit	:= nTamPre+nTamNum+nTamPar
	Local lAchouTit := .F.
	Local nTamBco	:= Tamsx3("A6_COD")[1]
	Local nTamAge	:= TamSx3("A6_AGENCIA")[1]
	Local nTamCta	:= Tamsx3("A6_NUMCON")[1]
	Local lMultNat 	:= IIF(mv_par12==1,.T.,.F.)
	Local aColsSEV 	:= {}
	Local lOk 		:= .F. //Controla se foi confirmada a distribuicao
	Local nTotLtEZ 	:= 0	//Totalizador da Bx Lote Mult Nat CC
	Local nHdlPrv	:= 0
	Local aArqConf	:= {}	// Atributos do arquivo de configuracao
	Local lCtbExcl	:= !Empty( xFilial("CT2") )
	Local aFlagCTB	:= {}
	Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local lF430PORT := ExistBlock("F430PORT")
	Local lAltPort 	:= .F.
	Local aDtMvFinOk := {} //Array para as datas de baixa válidas
	Local aDtMvFinNt := {} //Array para as datas de baixa inconsistentes com o parâmetro MV_DATAFIN
	Local lTrocaLP	:= .F.
	Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local lIRPFBaixa := .F.
	Local cPadAux	:= ""
	Local aCtBaixa := {}
	Local nX 	   := 0
	//DDA - Debito Direto Autorizado
	Local lUsaDDA	:= FDDAInUse()
	Local lProcDDA	:= .F.
	Local lF430COMP := ExistBlock( "F430COMP" )
	Local lFA430FIG	:= ExistBlock( "FA430FIG" )

	//Reestruturacao SE5
	Local oModelMov	:= Nil //Model de Movimento
	Local oSubFK5	:= Nil
	Local oSubFKA	:= ""
	Local cLog		:= ""
	Local cCamposE5	:= ""
	Local cChaveTit	:= ""
	Local cIDDoc	:= ""
	Local lBxCnab	:= GetMv("MV_BXCNAB") == "S"
	Local lCtMovPa	:= SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer  pelo Título(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
	Local cBcoOfi	:= ""
	Local cAgeOfi	:= ""
	Local cCtaOfi	:= ""
	Local cNatLote:= FINNATMOV("P")
	Local cLocRec := SuperGetMV( "MV_LOCREC" , .F. , .F. )
	Local aAreaCorr := {}
	Local lF430GRAFIL := ExistBlock("F430GRAFIL")
	Local cCGCFilHeader := ""
	Local aAreaFK2
	Local aAreaFK5
	Local aAreaSE5
	Local nValImp	:= 0
	Local nOldValPgto := 0
	Local nMoeda	:= 0
	Local nTxMoeda	:= 0
	Local lPagAnt	:= .F.
	Local cAliasTmp := GetNextAlias()
	Local nLinhas   := 0
	Local lArqErro  := .F.
	Local cCodForn	:= ""
	Local nRecnoSE2 := 0
	Local cTpDescSE5 := ""
	Local nEstOrig	:= 0
	Local nCasDec   := TamSx3("E2_TXMOEDA")[2]
	Local aContSX5	:= {}
	Local lOkSEB 	:= .T.
	Local lLanConPro := .T.
	Local lIntEAI080 := .F.
	Local lF430TXBX  := .F.
	Local nAcreDecre := 0
	Local aSE2       := {}
	Local aTitulo    := {}
	Local cChaveSEA  := ""
	Local nIndice    := 1
	Local lTemIndice := .F.
	Local nTamIdCNAB := TamSX3("E2_IDCNAB")[1]
	Local nBorderos	 := 0
	Local aBorderos	 := {}
	Local aTCBStatus := {}
	Local lStatusTCB := .F.
	Local lAgendado	 := .F.
	Local lFValAcess  := FindFunction("FValAcess")
	Local lPosicTit   := .F.
	
	Private cBanco, cAgencia, cConta
	Private cHist070, cArquivo
	Private lAut		:=.f., nTotAbat := 0
	Private cCheque 	:= " ", cPortado := " ", lAdiantamento := .F.
	Private cNumBor 	:= " ", cForne  := " " , cCgc := "", cDebito := ""
	Private cModSpb 	:= "1"
	Private cAutentica 	:= Space(25)
	Private cLote		:= Space(TamSX3("EE_LOTECP")[1])
	Private cBenef      := ""
	Private nMoedaBco	:= 0
	Private nVA         := 0

	If Type("aMsgSch") == "U"
		Private aMsgSch := {}
	Endif

	//Reestruturacao SE5
	PRIVATE nDescCalc 	:= 0
	PRIVATE nJurosCalc 	:= 0
	PRIVATE nMultaCalc 	:= 0
	PRIVATE nCorrCalc	:= 0
	PRIVATE nDifCamCalc	:= 0
	PRIVATE nImpSubCalc	:= 0
	PRIVATE nPisCalc	:= 0
	PRIVATE nCofCalc	:= 0
	PRIVATE nCslCalc	:= 0
	PRIVATE nIrfCalc	:= 0
	PRIVATE nIssCalc	:= 0
	PRIVATE nPisBaseR 	:= 0
	PRIVATE nCofBaseR	:= 0
	PRIVATE nCslBaseR 	:= 0
	PRIVATE nIrfBaseR 	:= 0
	PRIVATE nIssBaseR 	:= 0
	PRIVATE nPisBaseC 	:= 0
	PRIVATE nCofBaseC 	:= 0
	PRIVATE nCslBaseC 	:= 0
	PRIVATE nIrfBaseC 	:= 0
	PRIVATE nIssBaseC 	:= 0
	Private lVlrMaior := .F.
	Private nVlrMaior	:= 0
	Private cTpDesc		:= ""

	DEFAULT aParamB := {}

	lChqPre := .F.

	If __lVldExtC == Nil
		__lVldExtC := FindFunction("VldExtCNAB")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no Banco indicado                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cBanco  := mv_par05
	cAgencia:= mv_par06
	cConta  := mv_par07
	cSubCta := mv_par08

	If lExecJob // Anula parâmetro MV_LOCREC quando vem de schedule
		cLocRec := ""
	Endif

	dbSelectArea("SA6")
	SA6->(DbSetOrder(1))
	If SA6->(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
		nMoedaBco := SA6->A6_MOEDA
	EndIf

	dbSelectArea("SEE")
	SEE->(DbSetOrder(1))
	SEE->(dbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta))

	// Buscar a Conta Oficial. Abaixo eu seto os novos valores
	If !Empty(SEE->EE_CTAOFI)
		cBcoOfi	:= SEE->EE_CODOFI
		cAgeOfi	:= SEE->EE_AGEOFI
		cCtaOfi	:= SEE->EE_CTAOFI

		cBanco		:= SEE->EE_CODOFI
		cAgencia	:= SEE->EE_AGEOFI
		cConta		:= SEE->EE_CTAOFI
	endif

	If Empty(SEE->EE_NRBYTES)
		nBloco := If(MV_PAR10 == 1, 402, 242)
	Else
		nBloco := SEE->EE_NRBYTES+2
	EndIf

	If !SEE->(found())
		if !lExecJob
			Help(" ",1,"PAR150")
		Else
			Aadd(aMsgSch, STR0032+cBanco+"  "+STR0033+cAgencia+"  "+STR0034+cConta+"  "+STR0035+cSubCta) // "Parametros de Bancos nao encontrados para o Banco:" # "Agencia:" # "Conta:" # "Sub-Conta:"
		Endif

		//Atualiza o log de processamento com o erro
		ProcLogAtu("ERRO", "PAR150", Ap5GetHelp("PAR150"))
		lRet:= .F.
	Endif

	If lRet .And. lBxCnab // Baixar arquivo recebidos pelo CNAB aglutinando os valores
		If Empty(SEE->EE_LOTECP)
			cLoteFin := StrZero(1, TamSX3("EE_LOTECP")[1])
		Else
			cLoteFin := FinSomaLote(SEE->EE_LOTECP)
		EndIf

		cLoteFin := Iif(CheckLote("P",.F.), cLoteFin, GetNewLote())
	EndIf

	If lRet
		lRet := DtMovFin(dDatabase,,"1")
	EndIf

	IF !lRet
		return(.f.)
	Endif

	//Tratamento para gestão corporativa
	If FWSizeFilial() > 2
		If (FWModeAccess("CT2", 3) == "C") .Or. ( FWModeAccess("CT2", 2) == "C") .Or. ( FWModeAccess("CT2", 1) == "C")
			lCtbExcl := .F.
		EndIf
	EndIf

	If lRet
		cTabela := Iif( Empty(SEE->EE_TABELA), "17" , SEE->EE_TABELA )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a tabela existe           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aContSX5 := FWGetSX5(cTabela)
		If Empty(aContSX5)
			If ! lExecJob
				Help(" ",1,"PAR430")
			Else
				Aadd(aMsgSch, STR0036) // "Tabela 17 nao localizada no arquivo de tabelas SX5"
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento com o erro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ProcLogAtu("ERRO","PAR430",Ap5GetHelp("PAR430"))

			lRet := .F.
		Endif
	EndIf

	//Verifica se a contabilidade está em modo exclusivo e se foi solicitado o processamento de todas as filiais
	If lRet .And. mv_par11 == 2 .And. lCtbExcl .And. !lExecJob
		lRet := MsgYesNo(STR0015, STR0010) //Neste caso, o sistema não realiza a contabilização on-line. Confirma mesmo assim?
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se arquivo ja foi processado anteriormente	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. !(Chk430File())
		lRet := .F.
	Endif

	//Retorno Automatico via Job se o arquivo estiverno diretorio vai reprocessar sempre se for JOB
	If lExecJob .and. ! lRet
		ProcLogAtu("ALERTA",STR0017+Alltrim(mv_par03)+STR0018) 	// "Arquivo :" # " processado anteriormente."
		Aadd(aMsgSch, STR0017+Alltrim(mv_par03)+STR0018) 		// "Arquivo :" # " processado anteriormente."
	Endif

	//Altero banco da baixa pelo portador ?
	If lF430PORT
		lAltPort := ExecBlock("F430PORT",.F.,.F.)
	Endif


	For nX := 1 to Len(aContSX5)
		AADD(aTabela,{Alltrim(aContSX5[nX][4]),PadR(AllTrim(aContSX5[nX][3]),3)})
	Next nX
	ASize(aContSX5,0)
	aContSX5 := nil

	If lRet
		//Verifica o numero do Lote
		LoteCont("FIN")

		//Abre arquivo de configuracao
		cArqConf := mv_par04
		If !(File(cArqConf))
			if ! lExecJob
				Help(" ",1,"NOARQPAR")
			Else
				Conout(STR0037+cArqConf+STR0038) // "Arquivo de configuracao " # " nao localizado."
				Aadd(aMsgSch, STR0037+cArqConf+STR0038) // "Arquivo de configuracao " # " nao localizado."
			Endif
			//Atualiza o log de processamento com o erro
			ProcLogAtu("ERRO","NOARQPAR",Ap5GetHelp("NOARQPAR"))

			lRet:= .F.
		ElseIf !__lVldExtC .Or. (lRet :=  VldExtCNAB(SubStr(cArqConf, At(".", cArqConf) + 1), "FINA430"))
			If MV_PAR10 == 1
				nHdlConf := FOpen(cArqConf, 0 + 64)
			EndIf
		EndIf
	EndIf

	If lRet .And. ( MV_PAR10 == 1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Lˆ arquivo de configuracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nLidos:=0
		FSEEK(nHdlConf,0,0)
		nTamArq:=FSEEK(nHdlConf,0,2)
		FSEEK(nHdlConf,0,0)
		While nLidos <= nTamArq

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o tipo de qual registro foi lido ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			xBuffer:=Space(85)
			FREAD(nHdlConf,@xBuffer,85)

			IF SubStr(xBuffer,1,1) == CHR(1)
				nLidos+=85
				Loop
			EndIF
			IF SubStr(xBuffer,1,1) == CHR(3)
				Exit
			EndIF
			IF !lPosNum
				cPosNum:=Substr(xBuffer,17,10)
				nLenNum:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosNum:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosData
				cPosData:=Substr(xBuffer,17,10)
				nLenData:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosData:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosDesp
				cPosDesp:=Substr(xBuffer,17,10)
				nLenDesp:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDesp:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosDesc
				cPosDesc:=Substr(xBuffer,17,10)
				nLenDesc:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDesc:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosAbat
				cPosAbat:=Substr(xBuffer,17,10)
				nLenAbat:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosAbat:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosPrin
				cPosPrin:=Substr(xBuffer,17,10)
				nLenPrin:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosPrin:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosJuro
				cPosJuro:=Substr(xBuffer,17,10)
				nLenJuro:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosJuro:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosMult
				cPosMult:=Substr(xBuffer,17,10)
				nLenMult:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosMult:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosOcor
				cPosOcor:=Substr(xBuffer,17,10)
				nLenOcor:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosOcor:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosTipo
				cPosTipo:=Substr(xBuffer,17,10)
				nLenTipo:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosTipo:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosNsNum
				cPosNsNum := Substr(xBuffer,17,10)
				nLenNsNum := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosNsNum := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosRejei
			cPosRejei := Substr(xBuffer,17,10)
				nLenRejei := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosRejei := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosForne
			cPosForne := Substr(xBuffer,17,10)
				nLenForne := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosForne := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosCgc
				cPosCgc   := Substr(xBuffer,17,10)
				nLenCgc   := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosCgc   := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosDebito
				cPosDebito:=Substr(xBuffer,17,10)
				nLenDebito:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDebito:=.t.
				nLidos+=85
				Loop
			EndIF
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha arquivo de configuracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Fclose(nHdlConf)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre arquivo enviado pelo banco ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		//MV_LOCREC  -Parâmetro onde será gravado o diretório.
		If (lExecJob .Or. (Empty(cLocRec) .And. !lExecJob))
			cArqEnt := mv_par03
		Else
			//Verifica qual barra está o parâmetro , e o que está na ultima posição através do RAT
			If AT("\",alltrim(cLocRec))>0 .and. RAT("\",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) = 0
				cArqEnt := cLocRec+"\"+TRIM(mv_par03)
			ElseIf AT("\",alltrim(cLocRec))>0 .and. RAT("\",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) > 0
				cArqEnt := cLocRec+TRIM(mv_par03)
			ElseIf AT("/",alltrim(cLocRec))>0 .and. RAT("/",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) > 0
				cArqEnt  := SuperGetMV( "MV_LOCREC" , .F. , .F. )+TRIM(mv_par03)
			ElseIf AT("/",alltrim(cLocRec))>0 .and. RAT("/",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) = 0
				cArqEnt := cLocRec+"/"+TRIM(mv_par03)
			Endif
		Endif

		//Validar as Inconsistências
		If !Empty(cLocRec) .and. (Empty(mv_par03) .or. AT(":",mv_par03)>0 .or. (AT("/",mv_par03)>0 .or. AT("\",mv_par03)>0))
			Help(" ",1,"F150ARQ",,STR0023,1,0) //"Nome do Arquivo de Saida Inválido
			Return .F.
		Endif

		If !FILE(cArqEnt)
			If !lExecJob
				Help(" ",1,"NOARQENT")
			Else
				Aadd(aMsgSch, STR0039+cArqEnt+STR0040) // "Arquivo de entrada " # " nao localizado."
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento com o erro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ProcLogAtu("ERRO","NOARQENT",Ap5GetHelp("NOARQENT"))

			lRet:= .F.
		Else
			nHdlBco:=FOPEN(cArqEnt,0+64)
		EndIF
	EndIf

	If lRet
		//Lê arquivo enviado pelo banco
		nLidos:=0
		FSEEK(nHdlBco,0,0)
		nTamArq:=FSEEK(nHdlBco,0,2)
		FSEEK(nHdlBco,0,0)

		// Validação de Integridade do Arquivo de Retorno
		nLinhas := nTamArq/nBloco
		lArqErro := (nLinhas - Int(nLinhas)) <> 0 // Arquivo Corrompido

		If lArqErro
			lRet := .F.

			If !lExecJob
			lRet := MsgYesNo(STR0028+MV_PAR08+CRLF+STR0029, STR0010) // "Arquivo de retorno corrompido! De acordo com o Cadastro de Parametros de Bancos - Sub Conta: "
			EndIf
		EndIf
	EndIf

	If lRet
		lIntEAI080 := FWHasEAI("FINA080", Nil, Nil, .T.)
		lF430TXBX  := ExistBlock("F430TXBX")
		lTemIndice := !Empty(SEA->(IndexKey(4)))
		dbSelectArea("SED")
		dbSelectArea("SEB")

		//Desenha o cursor e o salva para poder moviment -lo
		ProcRegua(nLinhas)

		//Certifico de que o TRB esta fechado
		If (Select("TRB")<>0)
			dbSelectArea("TRB")
			dbCloseArea()
		EndIf

		//Gera arquivo de Trabalho
		AADD(aCampos,{"FILMOV"	,"C",IIf(lFWCodFil, FWGETTAMFILIAL, 2 ), 0})
		AADD(aCampos,{"BANCO"	,"C",TamSx3("A6_COD")[1],0})
		AADD(aCampos,{"AGENCIA"	,"C",TamSx3("A6_AGENCIA")[1],0})
		AADD(aCampos,{"CONTA"	,"C",TamSx3("A6_NUMCON")[1],0})
		AADD(aCampos,{"DATAD"	,"D",08,0})
		AADD(aCampos,{"NATURE"	,"C",TAMSX3("E2_NATUREZ")[1],0})
		AADD(aCampos,{"MOEDA"	,"C",TAMSX3("E2_MOEDA")[1],0})
		AADD(aCampos,{"TOTAL"	,"N",17,2})
		AADD(aCampos,{"FILORI"	,"C",IIf(lFWCodFil, FWGETTAMFILIAL, 2 ), 0})

		If(_oFina430 <> NIL)
			_oFina430:Delete()
			_oFina430 := NIL
		EndIf

		_oFina430 := FwTemporaryTable():New("TRB")
		_oFina430:SetFields(aCampos)
		_oFina430:AddIndex("1",{"FILMOV","BANCO","AGENCIA","CONTA","DATAD"})
		_oFina430:Create()

		//Carrega atributos do arquivo de configuracao
		aArqConf := Directory(mv_par04)

		Begin Transaction
			lContabiliza := mv_par09 == 1
			SEB->(dbSetOrder(1))

			While nLidos <= nTamArq
				IncProc()
				nDespes    :=0
				nDescont   :=0
				nAbatim    :=0
				nValRec    :=0
				nJuros     :=0
				nMulta     :=0
				nValCc     :=0
				nValPgto   :=0
				nMoeda	   :=0
				nTxMoeda   :=0
				nCM        :=0
				ABATIMENTO := 0
				lPagAnt	   := .F.
				lProcDDA   := .F.
				cFilAnt    := cFilOrig
				lPosSE2    := .F.
				nRecnoSE2  := 0
				nEstOrig   := 0
				nVA        := 0
				
				//Tipo qual registro foi lido
				If MV_PAR10 == 1
					xBuffer:=Space(nBloco)
					FREAD(nHdlBco,@xBuffer,nBloco)

					//Considera a primeira linha sempre como um cabe‡alho
					If lFA430FIG .And. (lHeader .And. SubStr(xBuffer,1,1) != "1" .And. Substr(xBuffer, 1, 3) != "001") .Or. (cBanco == "409" .And. SubStr(xBuffer, 1, 1) == "2")
						cCGCFilHeader := Substr(xBuffer, 12,14) // ler o novo cnpj do header
					EndIf

					If !lHeader
						lHeader := .T.
						nLidos	+= nBloco
						cCGCFilHeader := Substr(xBuffer, 12,14)
						Loop
					EndIf

					If SubStr(xBuffer, 1, 1) == "1" .Or. Substr(xBuffer, 1, 3) == "001" .Or. (cBanco == "409" .And. SubStr(xBuffer, 1, 1) == "2")  // Unibanco
						//Ler os valores do arquivo Retorno
						cNumTit := Substr(xBuffer, Int(Val(Substr(cPosNum, 1, 3))), nLenNum )
						cData   := Substr(xBuffer, Int(Val(Substr(cPosData,1, 3))), nLenData)
						cData   := ChangDate(cData, SEE->EE_TIPODAT)
						dBaixa  := Ctod(Substr(cData,1,2)+"/"+Substr(cData,3,2)+"/"+Substr(cData,5),"ddmm"+Replicate("y",Len(Substr(cData,5))))
						dDebito := dBaixa
						cTipo   := Substr(xBuffer,Int(Val(Substr(cPosTipo, 1,3))),nLenTipo )
						cNsNum  := " "

						If !Empty(cPosDesp)
							nDespes:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosDesp,1,3))),nLenDesp))/100,2)
						EndIf

						If !Empty(cPosDesc)
							nDescont:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosDesc,1,3))),nLenDesc))/100,2)
						EndIf

						If !Empty(cPosAbat)
							nAbatim:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosAbat,1,3))),nLenAbat))/100,2)
						EndIf

						If !Empty(cPosPrin)
							nValPgto :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosPrin,1,3))),nLenPrin))/100,2)
						EndIF

						If !Empty(cPosJuro)
							nJuros  :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosJuro,1,3))),nLenJuro))/100,2)
						EndIf

						If !Empty(cPosMult)
							nMulta  :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosMult,1,3))),nLenMult))/100,2)
						EndIf

						If !Empty(cPosNsNum)
							cNsNum  :=Substr(xBuffer,Int(Val(Substr(cPosNsNum,1,3))),nLenNsNum)
						EndIf

						IF !Empty(cPosRejei)
							cRejeicao  :=Substr(xBuffer,Int(Val(Substr(cPosRejei,1,3))),nLenRejei)
						EndIf

						If !Empty(cPosForne)
							cForne  :=Substr(xBuffer,Int(Val(Substr(cPosForne,1,3))),nLenForne)
						EndIf

						nTamEEOcor := IIF(cPaisLoc == "BRA", SEE->EE_TAMOCOR, 2)
						cOcorr     := Substr(xBuffer, Int(Val(Substr(cPosOcor, 1, 3))), nLenOcor)
						cOcorr     := PadR(Left(Alltrim(cOcorr), nTamEEOcor) , nTamOcor)

						If !Empty(cPosCgc)
							cCgc  :=Substr(xBuffer,Int(Val(Substr(cPosCgc,1,3))),nLenCgc)
						Endif

						If !Empty(cPosDebito)
							cDebito :=Substr(xBuffer,Int(Val(Substr(cPosDebito,1,3))),nLenDebito)
							cDebito :=ChangDate(cDebito,SEE->EE_TIPODAT)

							If !Empty(cDebito)
								dDebito :=Ctod(Substr(cDebito,1,2)+"/"+Substr(cDebito,3,2)+"/"+Substr(cDebito,5),"ddmm"+Replicate("y",Len(Substr(cDebito,5))))
							Endif
						Endif

						nCM     := 0
						cRastro	:= Substr(xBuffer, 264, 2) //Operacao de rastreamento = 30 (Fixo)
						cDDA    := Substr(xBuffer, 279, 2) //Operacao de rastreamento = "FS" (Fixo)

						//Rastreamento DDA - Bradesco
						If lUsaDDA .And. cBanco == "237" .And. cRastro == "30" .And. cDDA == "FS"
							cBcoForn := Substr(xBuffer, 096, 3) //01-03 Banco do cedente - Fornecedor
							cCodBar	 := ""						//Codigo de barras completo
							cFatorVc := ""						//Fator de Vencimento
							cMoeda	 := "9"						//Moeda do titulo (9 = Real)
							cDV		 := ""						//Digito verificador do codigo de barras (sera calculado)
							cVencto	 := ""						//Data de vencimento
							cOcorr	 := PadR("FS", nTamOcor)	//Forco Ocorrencia pois a mesma pode voltar vazia em caso de rastreamento DDA
							cVencto  := Substr(xBuffer, 166, 8)
							cVencto  := ChangDate(cVencto, SEE->EE_TIPODAT)
							cVencto  := Substr(cVencto, 1, 2) + "/" + Substr(cVencto, 3, 2) + "/" + Substr(cVencto, 5)
							cFatorVc := StrZero(ctod(cVencto) - ctod("07/10/97"), 4) //Fator de Vencimento
							cValPgto := Substr(xBuffer, 195, 10)

							//Bando do Cedente = Bradesco
							If cBcoForn == "237"
								//Campo Livre do codigo de barras
								//Agencia + Carteira + Nosso Numero +  Conta corrente + 0
								cCpoLivre := Substr(xBuffer, 100, 4) + Substr(xBuffer, 137, 2) + Substr(xBuffer, 140, 11)+ Substr(xBuffer, 111, 7) + "0"
							Else
								cCpoLivre:= Substr(xBuffer, 374, 25)
							Endif

							//Calculo do digito verificador do codigo de barras
							cDV := DV_BarCode(cBcoForn + cMoeda + cFatorVc + cValPgto + cCpoLivre)

							/*Montagem do código de barras:
							01-03 - Codigo do banco
							04-04 - Codigo da moeda
							05-05 - Digito verificador
							06-09 - Fator vencimento
							10-19 - Valor do documento
							20-44 - Campo Livre
							*/
							cCodBar :=	cBcoForn + cMoeda + cDV + cFatorVc + cValPgto + cCpoLivre
							lProcDDA := !Empty(cCodBar)
						Endif

						If lFa430Fil
							Execblock("FA430FIL", .F., .F., {xBuffer})
						Endif

						If lF430Var
							/*o array aValores permitirá que qualquer exceção ou necessidade seja tratado no ponto de entrada em PARAMIXB

							Estrutura de aValores
							Numero do Título	- 01
							data da Baixa		- 02
							Tipo do Título		- 03
							Nosso Numero		- 04
							Valor da Despesa	- 05
							Valor do Desconto	- 06
							Valor do Abatimento	- 07
							Valor Pagamento   	- 08
							Juros				- 09
							Multa				- 10
							Fornecedor			- 11
							Ocorrencia			- 12
							CGC					- 13
							nCM					- 14
							Rejeicao			- 15
							Linha Inteira		- 16*/
							aValores := ({cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer })
							ExecBlock("F430VAR", .F., .F., {aValores})
						EndIf

						If !(Empty(cNumTit))
							If Len(LTrim(cNumTit)) < nTamIdCNAB
								cNumTit := AjstIdCNAB(cNumTit)
							EndIf
							
							If !lProcDDA
								nRecnoSE2 := F430FilTit(cNumTit)
							EndIf
						EndIf

						//Verifica especie do titulo
						cEspecie := "  "

						If (nPos := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo, 1, 3))})) != 0
							cEspecie := aTabela[nPos][2]
						EndIf

						If cEspecie $ MVABATIM		// Nao lˆ titulo de abatimento
							nLidos += nBloco
							Loop
						EndIf

						//Ponto de entrada para permitir ou nao a baixa de um determinadotipo de titulo. PA por exemplo.
						If lFa430Pa .And. !(ExecBlock("FA430PA", .F., .F., cEspecie))
							nLidos += nBloco
							Loop
						Endif
					Else
						nLidos += nBloco
						Loop
					EndIf
				Else
					If Valtype(MV_PAR04) == "C"
						cArqConf := MV_PAR04
					Endif

					aLeitura   := ReadCnab2(nHdlBco,cArqConf,nBloco,aArqConf)
					cNumTit    := SubStr(aLeitura[1],1, nTamTit)
					cData      := aLeitura[04]
					cData      := ChangDate(cData,SEE->EE_TIPODAT)
					dBaixa     := Ctod(Substr(cData,1,2)+"/"+Substr(cData,3,2)+"/"+Substr(cData,5),"ddmm"+Replicate("y",Len(Substr(cData,5))))
					cTipo      := aLeitura[02]
					cNsNum     := aLeitura[11]
					nDespes    := aLeitura[06]
					nDescont   := aLeitura[07]
					nAbatim    := aLeitura[08]
					nValPgto   := aLeitura[05]
					nJuros     := aLeitura[09]
					nMulta     := aLeitura[10]
					cNsNum     := aLeitura[11]
					If cPaisLoc == "BRA" .and. SEE->EE_TAMOCOR > 0
						nTamEEOcor := SEE->EE_TAMOCOR
					Else
						nTamEEOcor := 2
					EndIf
					cOcorr     := PadR( Left(Alltrim(aLeitura[03]),nTamEEOcor) , nTamOcor)
					cForne     := aLeitura[16]
					dDebito	   := dBaixa
					xBuffer	   := aLeitura[17]

					//Segmento Z - Autenticacao
					If Len(aLeitura) > 17
						cAutentica := aLeitura[18]
					Endif

					//CGC
					If Len(aLeitura) > 19
						cCgc := aLeitura[20]
					Endif

					//Buscar a Conta Oficial
					If !Empty(cCtaOfi)
						cBanco   := cBcoOfi
						cAgencia := cAgeOfi
						cConta   := cCtaOfi
					ElseIf Len(aLeitura) > 20
						cBanco	 := If(ALLTRIM(mv_par05) $ aLeitura[21],mv_par05, PAD(aLeitura[21], nTamBco))
						cAgencia := If(ALLTRIM(mv_par06) $ aLeitura[22],mv_par06, PAD(aLeitura[22], nTamAge))
						cConta	 := If(ALLTRIM(mv_par07) $ aLeitura[23],mv_par07, PAD(aLeitura[23], nTamCta))
					Else
						cBanco   := mv_par05
						cAgencia := mv_par06
						cConta   := mv_par07
					Endif

					//DDA - Debito Direto Autorizado
					If lUsaDDA
						If Len(aLeitura) > 23
							//Caso o CNPJ do Fornecedor seja retornado no Segmento H, assumo este valor
							If !Empty(aLeitura[24]) .And. Substr(aLeitura[24],1,7) != "0000000"
								cCgc := aLeitura[24]
							Endif

							cCodBar  := aLeitura[25]
							lProcDDA := !Empty(cCodBar)
						Endif
						If Len(aLeitura) > 25
							//Caso o CNPJ da empresa seja retornado no Segmento H, assumo este valor
							If !Empty(aLeitura[26]) .And. Substr(aLeitura[26],1,7) != "0000000"
								cCGCFilHeader := aLeitura[26]
							Endif
						Endif
					Endif

					If Empty(cNumTit) .And. !lProcDDA
						nLidos += nBloco
						Loop
					Endif

					If lF430Var
						/*o array aValores permitirá que qualquer exceção ou necessidade seja tratado no ponto de entrada em PARAMIXB.

						Estrutura de aValores
						Numero do Título	- 01
						Data da Baixa		- 02
						Tipo do Título		- 03
						Nosso Numero		- 04
						Valor da Despesa	- 05
						Valor do Desconto	- 06
						Valor do Abatiment	- 07
						Valor Pagamento   	- 08
						Juros				- 09
						Multa				- 10
						Fornecedor			- 11
						Ocorrencia			- 12
						CGC					- 13
						nCM					- 14
						Rejeicao			- 15
						Linha Inteira		- 16
						Autenticacao 	    - 17
						Banco             	- 18
						Agencia           	- 19
						Conta             	- 20*/
						aValores := ({cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer, cAutentica, cBanco, cAgencia, cConta})
						ExecBlock("F430VAR", .F., .F., {aValores})
					Endif

					If !(Empty(cNumTit))
						//Verifica se possui espaço em branco antes do número
						If Len(LTrim(cNumTit)) < nTamIdCNAB
							cNumTit := AjstIdCNAB(cNumTit)
						EndIf
						
						If !lProcDDA
							nRecnoSE2 := F430FilTit(cNumTit)
						EndIf
					EndIf

					//Verifica especie do titulo
					cEspecie	:= "  "

					If (nPos := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo,1,3))})) != 0
						cEspecie := aTabela[nPos][2]
					EndIf

					If cEspecie $ MVABATIM			// Nao lˆ titulo de abatimento
						Loop
					EndIf

					//Ponto de entrada para permitir ou nao a baixa de um determinadotipo de titulo. PA por exemplo
					If lFa430Pa .And. !(ExecBlock("FA430PA",.F.,.F.,cEspecie))
						Loop
					Endif
				EndIf
				
				If mv_par11 == 1 .And. SE2->E2_FILIAL <> FwxFilial("SE2")
					lOkSEB := SEB->(DbSeek(xFilial("SEB")+mv_par05+cOcorr+"P"))

					If !lProcDDA .OR. (lProcDDA .And. ((lOkSEB .And. SEB->EB_OCORR <> "02") .OR. !lOkSEB))
						Loop
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se existe o titulo no SE2. Caso este titulo nao seja ³
				//³ localizado, passa-se para a proxima linha do arquivo retorno. ³
				//³ O texto do help sera' mostrado apenas uma vez, tendo em vista ³
				//³ a possibilidade de existirem muitos titulos de outras filiais.³
				//³ OBS: Sera verificado inicialmente se nao existe outra chave   ³
				//³ igual para tipos de titulo diferentes.                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				lHelp     := .F.
				lAchouTit := .F.
				lPosicTit := .f.
				//Verifica a data de baixa do arquivo em relação ao parâmetro MV_DATAFIN
				If AScan(aDtMvFinOk , dBaixa ) == 0
					If AScan(aDtMvFinNt , dBaixa ) == 0
						If !DtMovFin(dBaixa , .F.,"1")
							aAdd(aDtMvFinNt , dBaixa )

							If mv_par10 == 1
								nLidos += nBloco
							EndIf

							ProcLogAtu("ERRO" , "DTMOVFIN" , Ap5GetHelp( "DTMOVFIN" ) + " " + DtoC( dBaixa ) )
							Loop
						Else
							aAdd( aDtMvFinOk , dBaixa )
						EndIf
					Else
						If mv_par10 == 1
							nLidos += nBloco
						EndIf

						Loop
					EndIf
				EndIf

				aValores := ( { cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer })

				//Processamento normal - Nao se trata de processamento de arquivo de DDA
				If !lProcDDA
					If lFa430SE2
						lPosicTit := ExecBlock("FA430SE2", .F., .F., {aValores})						
						lAchouTit := IIf(lExecJob .And. Valtype(lPosicTit) == "L", lPosicTit, lAchouTit)
					Else
						//Se processa todas as filiais, tem o novo indice somente por IDCNAB e a filial da SE2 estah preenchida.
						If lCtbExcl .And. mv_par11 == 2 .And. !Empty(xFilial("SE2"))
							mv_par09 := 2 //Desligo contabilizacao on-line
						Endif

						//Se nao achou, utiliza metodo antigo (titulo)
						If nRecnoSE2 == 0 .And. SE2->(!Found())
							SE2->(dbSetOrder(1))

							//Chave retornada pelo banco
							cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)

							While !lAchouTit
								If !SE2->(DbSeek(xFilial() + cChave430))
									nPos := Ascan(aTabela, {|aVal|aVal[1] == AllTrim(Substr(cTipo,1,3))},nPos+1)

									If nPos != 0
										cEspecie := aTabela[nPos][2]
										cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
									Else
										Exit
									Endif
								Else
									lAchouTit := .T.
								Endif
							Enddo

							//Chave retornada pelo banco com a adicao de espacos para tratar chave enviada ao banco com
							//tamanho de nota de 6 posicoes e retornada quando o tamanho da nota e 9 (atual)
							If !lAchouTit
								cNumTit   := SubStr(cNumTit, 1, nTamPre) + Padr(Substr(cNumTit, 4, 6), nTamNum) + SubStr(cNumTit, 10, nTamPar)
								cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
								nPos      := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo, 1, 3))})

								While !lAchouTit
									If !dbSeek(xFilial()+cChave430)
										nPos := Ascan(aTabela, {|aVal|aVal[1] == AllTrim(Substr(cTipo,1,3))},nPos+1)

										If nPos != 0
											cEspecie  := aTabela[nPos][2]
											cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
										Else
											Exit
										Endif
									Else
										lAchouTit := .T.
									Endif
								Enddo
							Endif

							//Se achou o titulo, verificar o CGC do fornecedor
							If lAchouTit
								cNumSe2   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
								cChaveSe2 := IIf(!Empty(cForne), cNumSe2 + SE2->E2_FORNECE, cNumSe2)
								nPosEsp	  := nPos	// Gravo nPos para volta-lo ao valor inicial, caso encontre o titulo

								While SE2->(!Eof()) .And. SE2->E2_FILIAL + cChaveSe2 == xFilial("SE2") + cChave430
									nPos := nPosEsp

									If Empty(cCgc)
										Exit
									Endif

									SA2->(DbSetOrder(1))

									If (SA2->(DbSeek(xFilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA))) .And. (Substr(SA2->A2_CGC, 1, 14) == cCGC .Or. StrZero(Val(SA2->A2_CGC), 14, 0) == StrZero(Val(cCGC), 14, 0))
										Exit
									Endif

									SE2->(DbSkip())
									cNumSe2   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
									cChaveSe2 := IIf(!Empty(cForne), cNumSe2 + SE2->E2_FORNECE, cNumSe2)
									nPos 	  := 0
								Enddo
							EndIf
						Else
							nPos := 1
							lAchouTit := If(lAchouTit, lAchouTit, nRecnoSE2 > 0)
						EndIf

						lHelp := nPos == 0
					EndIf

					If !lUmHelp .And. lHelp
						if ! lExecJob
							Help(" ",1,"NOESPECIE",,cNumTit+	" "+cEspecie,5,1)
							lUmHelp := .T.
						Else
							Aadd(aMsgSch, STR0041+cEspecie+STR0042+cNumTit) // "Especie " # " nao localizada para o titulo "
						Endif

						//Atualiza o log de processamento com o erro
						ProcLogAtu("ERRO", "NOESPECIE", Ap5GetHelp("NOESPECIE"))
					Endif
				EndIf

				// Retorno Automatico via Job controla o status para emissao do relatorio de processamento
				If lExecJob
					cStProc := ""
					
					If !lAchouTit .And. !lProcDDA
						cStProc := STR0019 // "Titulo Inexistente"
						Aadd(aFa205R, {cNumTit,"", "", dBaixa,	0, nValPgto, cStProc })
						Aadd(aMsgSch, STR0019 +": "+ cNumTit)
					Elseif lHelp
						cStProc := STR0020 // "Titulo com Erro"
					Endif
				Endif

				If !lHelp .Or. (lExecJob .And. !lUmHelp)
					If !SEB->(DbSeek(xFilial("SEB")+mv_par05+cOcorr+"P"))
						if !lExecJob
							Help(" ",1,"HPFA430OCORR", Nil, STR0025 + Alltrim(cOcorr) + STR0026 + Alltrim(mv_par05) + STR0027, 3, 1) //"Não existe o código da ocorrência informada: " ## " para o banco: " ## " - Cadastre a ocorrência no SEB."
						Else
							Aadd(aMsgSch, STR0043 + cOcorr + STR0044) // "Ocorrencia " # " nao localizada na tabela SEB."
						Endif

						//Atualiza o log de processamento com o erro
						ProcLogAtu("ERRO","FA430OCORR",Ap5GetHelp("FA430OCORR"))
					Endif

					//Reposicionar o SEB para uma chave diferente, que considere também, campos especificos criados no SEB
					If lFa430Oco
						ExecBlock("FA430OCO", .F., .F., {aValores})
					Endif

					lStatusTCB := _lExistTcb .and. SA6->A6_TCB == "1"
					lAgendado := .T.

					dbSelectArea("SE2")
					If SEB->EB_OCORR $ "01|06|07|08" //Baixa do Titulo
						lLanConPro := .T.
						cPadrao    := "532"

						If lFA430LP
							lTrocaLP:= ExecBlock("FA430LP",.F.,.F.)
						Endif

						If (lPagAnt := (SE2->E2_TIPO $ MVPAGANT))
							cPadrao    := "513"
							lLanConPro := lCtMovPA
						ElseIf !lTrocaLP
							cPadrao := "530"
						EndIf

						If cPadrao != cPadAux
							lPadrao := VerPadrao(cPadrao)
							cPadAux := cPadrao
						EndIf

						//Monta Contabilizacao
						If !lCabec .And. lPadrao .And. lContabiliza
							nHdlPrv := HeadProva(cLote, "FINA430", substr( cUsuario, 7, 6 ), @cArquivo )
							lCabec  := .T.
						EndIf

						lAgendado   := .F.
						nValEstrang := SE2->E2_SALDO
						lDesconto   := .F.
						nTotAbat	:= SumAbatPag(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_FORNECE,SE2->E2_MOEDA,"S",dBaixa,SE2->E2_LOJA)
						ABATIMENTO  := nTotAbat
						
						If lFValAcess
							nVA := FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ,;
							.F., "", "P", dDataBase, Nil, SE2->E2_MOEDA, SE2->E2_MOEDA, SE2->E2_TXMOEDA, "", .F.)
						EndIf						
						
						//Ajusta tamanho suportado pelo campo de Autenticacao Bancÿria
						cAutentica	:= PadR(Alltrim(cAutentica), TamSx3("FK2_AUTBCO")[1])

						If !Empty(cCtaOfi) .and. !lAltPort
							cBanco		:= cBcoOfi
							cAgencia	:= cAgeOfi
							cConta		:= cCtaOfi
						ElseIf lAltPort
							SEA->(dbSetOrder(4) )
							SEA->(MsSeek( xFilial("SEA", SE2->E2_FILORIG) + SE2->( E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA )))
							cBanco   := If(Empty(SEA->EA_PORTADO), cBanco, SEA->EA_PORTADO)
							cAgencia := If(Empty(SEA->EA_AGEDEP), cAgencia, SEA->EA_AGEDEP)
							cConta   := If(Empty(SEA->EA_NUMCON), cConta, SEA->EA_NUMCON)
						ElseIf Empty(cBanco+cAgencia+cConta)
							cBanco      := mv_par05
							cAgencia    := mv_par06
							cConta      := mv_par07
						Endif

						cHist070 := STR0008

						//Verifica se a despesa esta descontada do valor principal
						If SEE->EE_DESPCRD == "S"
							nValPgto += nDespes
						EndIF

						nTotAger += nValPgto
						cLanca   := Iif(lPadrao .And. lContabiliza .And. lLanConPro, "S", "N")
						cBenef   := SE2->E2_NOMFOR
						cTpDesc  := "I"

						//Ponto de Entrada para Tratamento baixa
						If ExistBlock("FA430LRM")
							ExecBlock("FA430LRM",.F.,.F.,{xBuffer})
						Endif

						SX1->(DbSetOrder(1))
						If SX1->(DbSeek(PadR("AFI430", Len(SX1->X1_GRUPO), " ") + "13"))
							cTpDescSE5 := If( mv_par13 == 2 , "C" , "I")
							cTpDesc := cTpDescSE5  //Variável private utilizada na fa080grv()
						EndIf

						If SE2->E2_TIPO $ MVPAGANT+"|"+MVTXA
							DbSelectArea("SE5")
							SE5->(DbSetOrder(7))
							SE5->(DbGoTop())
							lAchouSE5 := SE5->(DbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

							//Busca movimentação já existente para este PAGAMENTO ANTECIPADO
							If !lAchouSE5 .Or. (lAchouSE5 .And. SE5->E5_TIPODOC == "BA" .And. SE5->E5_MOTBX == "PCC" .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) > 0)

								cCamposE5 := "{"
								cCamposE5 += " {'E5_DTDIGIT', dDataBase  }"
								cCamposE5 += ",{'E5_LOTE'	, '" + cLoteFin	 + "'}"
								cCamposE5 += ",{'E5_TIPO'	, '" + If(lPagAnt, MVPAGANT, MVTXA)	 + "'}"
								cCamposE5 += ",{'E5_BENEF'  , '" + RemoveAsp(Iif(Empty(cBenef), SA2->A2_NOME, cBenef))+"'   }"
								cCamposE5 += ",{'E5_PREFIXO', '" + SE2->E2_PREFIXO	+ "'}"
								cCamposE5 += ",{'E5_NUMERO'	, '" + SE2->E2_NUM		+ "'}"
								cCamposE5 += ",{'E5_PARCELA', '" + SE2->E2_PARCELA	+ "'}"
								cCamposE5 += ",{'E5_CLIFOR'	, '" + SE2->E2_FORNECE	+ "'}"
								cCamposE5 += ",{'E5_FORNECE', '" + SE2->E2_FORNECE	+ "'}"
								cCamposE5 += ",{'E5_LOJA'	, '" + SE2->E2_LOJA		+ "'}"
								IF !EMPTY(cTpDescSE5)
									cCamposE5 += ",{'E5_TPDESC'  , '"+ cTpDescSE5 +"'}"
								ENDIF
								IF !EMPTY(cAutentica)
									cCamposE5 += ",{'E5_AUTBCO'  , '"+ cAutentica +"'}"
								ENDIF
								cCamposE5 += ",{'E5_MOTBX'	, 'NOR'}"
								cCamposE5 += "}"

								oModelMov := FWLoadModel("FINM030")					//Model de Movimento a Receber
								oModelMov:SetOperation( MODEL_OPERATION_INSERT )	//Inclusao
								oModelMov:Activate()
								oModelMov:SetValue( "MASTER", "E5_GRV"		,.T.		)	//Informa se vai gravar SE5 ou não
								oModelMov:SetValue( "MASTER", "NOVOPROC"	,.T.		)	//Informa que a inclusão será feita com um novo número de processo
								oModelMov:SetValue( "MASTER", "E5_CAMPOS"	,cCamposE5 )	//Informa os campos da SE5 que serão gravados indepentes de FK5
								oSubFK5 := oModelMov:GetModel("FK5DETAIL")
								oSubFKA := oModelMov:GetModel("FKADETAIL")
								oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
								oSubFKA:SetValue( "FKA_TABORI", "FK5" )

								cChaveTit := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
								cIDDoc    := FINGRVFK7("SE2", cChaveTit)

								oSubFK5:SetValue( "FK5_ORIGEM"	, FunName() )
								oSubFK5:SetValue( "FK5_DATA"	, dBaixa )
								oSubFK5:SetValue( "FK5_VALOR"	, SE2->E2_VLCRUZ )
								oSubFK5:SetValue( "FK5_VLMOE2"	, SE2->E2_VALOR )
								oSubFK5:SetValue( "FK5_MOEDA"	, StrZero(SE2->E2_MOEDA,2))
								oSubFK5:SetValue( "FK5_NATURE"	, SE2->E2_NATUREZ	)
								oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
								oSubFK5:SetValue( "FK5_TPDOC"	, If(lPagAnt,"PA","VL"))
								oSubFK5:SetValue( "FK5_HISTOR"	, SE2->E2_HIST )
								oSubFK5:SetValue( "FK5_BANCO"	, cBanco )
								oSubFK5:SetValue( "FK5_AGENCI"	, cAgencia )
								oSubFK5:SetValue( "FK5_CONTA"	, cConta )
								oSubFK5:SetValue( "FK5_DTDISP"	, dBaixa )
								oSubFK5:SetValue( "FK5_FILORI"	, cFilAnt )
								oSubFK5:SetValue( "FK5_IDDOC"   , cIDDoc )
								oSubFK5:SetValue( "FK5_LA"	    , Iif(cLanca == "S" .And. !lUsaFlag, "S", "N"))
								oSubFK5:SetValue( "FK5_CCUSTO"  , SE2->E2_CCUSTO)

								If SpbInUse()
									oSubFK5:SetValue( "FK5_MODSPB"	, SE2->E2_MODSPB )
								Endif

								If SE2->E2_RATEIO == "S"
									oSubFK5:SetValue( "FK5_RATEIO",  "1" )
								Else
									oSubFK5:SetValue( "FK5_RATEIO",  "2" )
								EndIf

								If oModelMov:VldData()
									oModelMov:CommitData()
									SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
								Else
									lRet := .F.
									cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[6])
									Help( ,,"FA430GerPA",,cLog, 1, 0 )
								Endif

								oModelMov:DeActivate()
								oModelMov:Destroy()
								oModelMov := Nil
								oSubFK5   := Nil
								oSubFKA	:= Nil

								If lPadrao .And. cLanca == "S" .and. !lUsaFlag
									RecLock("SE2",.F.)
									SE2->E2_LA	:= "S"
									MsUnlock()
								EndIf

								If lUsaFlag // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, { "E5_LA", "S", "SE5", SE5->( RecNo() ), 0, 0, 0} )
									aAdd( aFlagCTB, { "E2_LA", "S", "SE2", SE2->( RecNo() ), 0, 0, 0} )
								EndIf

								If SE2->E2_TIPO $ MVTXA
									Reclock("SE2",.F.)
									SE2->E2_OK := 'TA'
									SE2->(MsUnlock())
								EndIf

								AtuSalBco(cBanco, cAgencia, cConta, SE5->E5_DTDISPO, SE5->E5_VALOR, "-")
								lBaixou  := .T.
								lMovAdto := .T.
							EndIf
						Else
							nTxMoeda := SE2->E2_TXMOEDA
							nMoeda   := SE2->E2_MOEDA
							nAcresc  := SE2->E2_SDACRES
							nDecresc := SE2->E2_SDDECRE
							
							If nMoeda != nMoedaBco .And. nMoeda > 0 .And. nMoedaBco > 0
								If lF430TXBX
									aTitulo  := {SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, dBaixa}
									aSE2     := SE2->(GetArea())
									nTxMoeda := ExecBlock("F430TXBX", .F., .F., aTitulo)

									RestArea(aSE2)
									FwFreeArray(aSE2)
									FwFreeArray(aTitulo)
								ElseIf nMoeda > 1 .And. (nTxMoeda <= 0 .Or. !Empty(SE2->E2_DTVARIA))
									nTxMoeda := RecMoeda(Iif(Empty(SE2->E2_DTVARIA), dBaixa, SE2->E2_DTVARIA), nMoeda)
								EndIf
								
								If (nAcresc+nDecresc) > 0
									nAcreDecre := IIf(nAcresc > 0, nAcresc, nDecresc)
									nAcresc := Round(xMoeda(nAcreDecre, nMoeda, nMoedaBco, dBaixa, nCasDec, nTxMoeda), 2)
									
									If nDecresc > 0
										nDecresc := nAcresc
										nAcresc := 0
									EndIf
								EndIf
								
								If nVA != 0
									nVA := xMoeda(nVA, nMoeda, nMoedaBco, dBaixa, nCasDec, nTxMoeda)
								EndIf							
							EndIf
							
							If nDescont > 0 // Valida se o banco retornou desconto no arquivo.
								nDescont := nDescont - nDecresc
							Endif

							If nJuros > 0 // Valida se o banco retornou o juros no arquivo.
								nJuros	:= nJuros - nAcresc
							Endif
							
							If !lMVCNBImpg .And. nMoeda > 1 .And. nMoedaBco > 0 .And. nMoeda != nMoedaBco
								nEstOrig := (nValPgto - (nJuros+nMulta+nAcresc)) + (nDescont+nDecresc) - Round(nVA, 2)
								
								//Converte para a moeda do titulo
								nEstOrig 	:= Round(xMoeda(nEstOrig, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda) ,2)
								nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda) ,2)
								
								//calcula correção monetaria
								FA080CORR(nEstOrig, nTxMoeda)
							EndIf

							If cPaisLoc == "BRA"
								If lMVCNBImpg
									SA2->(DbSetOrder(1))
									SED->(DbSetOrder(1))
									SA2->(DbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->(E2_FORNECE+E2_LOJA)))
									SED->(DbSeek(xFilial("SED", SE2->E2_FILORIG)+SE2->E2_NATUREZ))

									aTit        := {}
									lMsErroAuto := .F.
									lIRPFBaixa  := SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT .And. SED->ED_CALCIRF == "S"
									nOldValPgto	:= nValPgto
									nValPgto    := (nValPgto - (nJuros+nMulta+nAcresc)) + (nDescont+nDecresc)
									nValImp     := SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_ISS+E2_INSS)
									nVlrCnab    := SE2->E2_VALOR - nTotAbat
									nVlrCnab	:= (nVlrCnab + (nJuros+nMulta+nAcresc)) - (nDescont+nDecresc) + Round(nVA, 2)
									
									//IRRF
									If lIRPFBaixa .And. SE2->E2_IRRF > 0
										nVlrCnab -= SE2->E2_IRRF
									EndIf

									//PCC
									If lPCCBaixa .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
										nVlrCnab -= SE2->(E2_PIS+E2_COFINS+E2_CSLL)
									EndIf

									If nMoeda > 1 .And. nMoedaBco > 0 .And. nMoeda != nMoedaBco
										nOldValPgto := xMoeda(nOldValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda)
										nValPgto    := xMoeda(nValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda)
									EndIf

									nOldValPgto := Round(nOldValPgto, 2)
									nValPgto    := Round(nValPgto, 2)

									Do Case
										Case nOldValPgto == 0
											lRet := .F.
										Case nOldValPgto == nVlrcnab
											cTipoBx := "Baixa Total por CNAB"
										Case nOldValPgto - nValImp == nVlrcnab 		// Caso o cliente pague o valor bruto do t­tulo ao inv?s do l­quido
											cTipoBx := "Baixa Total por CNAB"
											nOldValPgto -= nValImp
										Case nOldValPgto + nValImp < nVlrcnab
												cTipoBx := "Baixa parcial por CNAB"
										Case nOldValPgto + nValImp > nVlrcnab
											cTipoBx := "Baixa Total a mais por CNAB"
											lVlrMaior	:= .T.
											nVlrMaior	:= nOldValPgto - nVlrcnab
									EndCase

									If lRet
										AADD(aTit, {"E2_FILIAL",    xFilial("SE2"),         Nil})
										AADD(aTit, {"E2_PREFIXO",   SE2->E2_PREFIXO,        Nil})
										AADD(aTit, {"E2_NUM",       SE2->E2_NUM,            Nil})
										AADD(aTit, {"E2_PARCELA",   SE2->E2_PARCELA,        Nil})
										AADD(aTit, {"E2_TIPO",      SE2->E2_TIPO,           Nil})
										AADD(aTit, {"E2_FORNECE",   SE2->E2_FORNECE,        Nil})
										AADD(aTit, {"E2_LOJA",      SE2->E2_LOJA,           Nil})
										AADD(aTit, {"AUTMOTBX",     cMotbx,                 Nil})
										AADD(aTit, {"AUTBANCO",     cBanco,                 Nil})
										AADD(aTit, {"AUTAGENCIA",   cAgencia,               Nil})
										AADD(aTit, {"AUTCONTA",     cConta,                 Nil})
										AADD(aTit, {"AUTDTBAIXA",   dBaixa,                 Nil})
										AADD(aTit, {"AUTDTCREDITO", dDebito,                Nil})
										AADD(aTit, {"AUTHIST",      cTipoBx,                Nil})
										AADD(aTit, {"AUTVLRPG",     (nValPgto - nVlrMaior), Nil})
										AADD(aTit, {"AUTJUROS",     nJuros,                 Nil})
										AADD(aTit, {"AUTDESCONT",   nDescont,               Nil})
										AADD(aTit, {"AUTMULTA",     nMulta,                 Nil})
										AADD(aTit, {"AUTACRESC",    nAcresc,                Nil})
										AADD(aTit, {"AUTDECRESC",   nDecresc,               Nil})
										AADD(aTit, {"AUTTXMOEDA",   nTxMoeda,               Nil})
										AADD(aTit, {"AUTVLRVA",     nVA,                    Nil})
										
										MSExecAuto({|x, y, a, b, c, d, e, f, g| FINA080(x, y, a, b, c, d, e, f, g)}, aTit, 3,,,,,,@aCtBaixa, cLanca)
										lBaixou := .T.

										If lMsErroAuto  
											If !IsBlind()
												MOSTRAERRO()
											EndIf
											DisarmTransaction()
											lBaixou := .F.
										EndIf
										If lExecJob  .and. !EMPTY(aParamB)  // Retorno Automatico via Job
											For nX := 1 To LEN(aParamB)
												If 'MV_PAR' $ UPPER(aParamB[nX,1])
													&(aParamB[nX,1]) := aParamB[nX,2]
												EndIf
											Next nX
										Else
											pergunte("AFI430",.F.)
										Endif
									Endif
								Else
									lBaixou  := fA080Grv(lPadrao, .F., .T., cLanca, mv_par03, nTxMoeda,,,,,,@aCtBaixa) // Retorno Automatico via Job
									lMovAdto := .F.
								Endif
							Else
								lBaixou  := fA080Grv(lPadrao,.F.,.T.,cLanca, mv_par03,,,,,,,@aCtBaixa) // Retorno Automatico via Job
								lMovAdto := .F.
							EndIf

							If lBaixou .And. lLanConPro .And. !Empty(aCtBaixa) .And. !lUsaFlag
								aAreaFK2 := FK2->(GetArea())
								aAreaFK5 := FK5->(GetArea())
								aAreaSE5 := SE5->(GetArea())

								For nX := 1 To Len(aCtBaixa)
									If aCtBaixa[nX, 1] == "FK2"
										dbSelectArea("FK2")
										FK2->(dbSetOrder(1))

										If FK2->(dbSeek( xFilial("FK2") + aCtBaixa[nX, 2]))
											RecLock("FK2",.F.)
											FK2->FK2_LA := "S"
											MsUnlock()
										EndIf
									ElseIf aCtBaixa[nX, 1] == "FK5"
										dbSelectArea("FK5")

										FK5->(dbSetOrder(1))
										If FK5->(dbSeek( xFilial("FK5") + aCtBaixa[nX, 2]))
											RecLock("FK5",.F.)
											FK5->FK5_LA := "S"
											MsUnlock()
										EndIf
									ElseIf aCtBaixa[nX, 1] == "SE5"
										dbSelectArea("SE5")
										DbGoTo(aCtBaixa[nX, 2])

										If SE5->(!BoF() .And. !EoF())
											RecLock("SE5",.F.)
											SE5->E5_LA := "S"
											MsUnlock()
										EndIf
									EndIf
								Next nX

								aCtBaixa := {}
								RestArea(aAreaFK2)
								RestArea(aAreaFK5)
								RestArea(aAreaSE5)
							EndIf
						EndIf

						// Retorno Automatico via Job armazena os dados do titulo para emissao de relatorio de processamento
						If lExecJob
							If lBaixou
								Aadd(aFa205R, {SE2->E2_NUM,	SE2->E2_FORNECE,SE2->E2_LOJA,dBaixa,SE2->E2_VALOR, nValPgto, "Baixado ok"})
							Else
								Aadd(aFa205R, {SE2->E2_NUM,	SE2->E2_FORNECE,SE2->E2_LOJA,dBaixa,SE2->E2_VALOR, nValPgto, cStProc})
							Endif
						Endif

						If lBaixou .And. !lMovAdto //somente gera pro lote quando nao for PA para nao duplicar no Extrato
							dbSelectArea("TRB")

							If !TRB->(DbSeek(xFilial("SE5")+cBanco+cAgencia+cConta+Dtos(dDebito)))
								Reclock("TRB",.T.)
								TRB->FILMOV  := xFilial("SE5")
								TRB->BANCO   := cBanco
								TRB->AGENCIA := cAgencia
								TRB->CONTA   := cConta
								TRB->DATAD   := dDebito
								TRB->NATURE  := cNatLote
								TRB->MOEDA   := StrZero(nMoedaBco, 2)
								TRB->FILORI  := cFilAnt
							Else
								Reclock("TRB",.F.)
							Endif

							TRB->TOTAL += nValPgto
							TRB->(MsUnlock())
						Endif

						If lUsaFlag .and. lBaixou
							Aadd(aFlagCTB, {"E5_LA", "S", "SE5", SE5->( RecNo() ), 0, 0, 0} )
						EndIf

						If lF430Baixa
							Execblock("F430BXA",.F.,.F.)
						EndIf

						If lBaixou
							If lMultNat .And. (SE2->E2_MULTNAT == "1")
								MultNatB("SE2", .F., "1", @lOk, @aColsSEV, @lMultNat, .T.)

								If lOk
									MultNatC("SE2", @nHdlPrv, @nTotal, @cArquivo, (mv_par09 == 1), .T., "1", @nTotLtEZ, lOk, aColsSEV, lBaixou)
								Endif
							ElseIf lCabec .And. lPadrao .And. lContabiliza .And. lLanConPro
								nTotal += DetProva(nHdlPrv, cPadrao, "FINA430" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/,/*aDadosProva*/)
							Endif
						EndIf
					EndIf

					If SEB->EB_OCORR == "03" //Titulo Rejeitado

						lAgendado := .F.

						dbSelectArea("SE2")
						SE2->(DbSetOrder(11))

						If !SE2->(DbSeek(xFilial("SE2")+Substr(cNumTit, 1, nTamTit)))
							SE2->(DbSetOrder(1))
							SE2->(DbSeek(xFilial()+Pad(cNumTit,nTamTit)+cEspecie))
						Endif

						dbSelectArea("SEA")
						nIndice := 1

						If  lTemIndice .And. mv_par11 == 2 .And. !Empty(SE2->E2_FILORIG)
							nIndice := 4
							cChaveSEA := SE2->(E2_FILORIG+E2_NUMBOR)+"P"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
						Else
							cChaveSEA := xFilial("SEA")+SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
						EndIf

						SEA->(DbSetOrder(nIndice))
						If SEA->(DbSeek(cChaveSEA)) .And. SE2->E2_SALDO != 0
							//PONTO DE ENTRADA F430REJ - Tratamento de dados de titulo rejeitado antes de "zerar" os dados do mesmo
							If lF430Rej
								Execblock("F430REJ",.F.,.F.)
							Endif

							FA590Canc()// Chamada Função FA590Canc para que o Título seja retirado corretamente do borderô Imp.
						EndIf

					EndIf

					//DDA - Debito Direto Autorizado
					If lUsaDDA .And. lProcDDA .And. SEB->EB_OCORR $ "02" //Entrada de titulo via DDA

						lAgendado := .F.

						SA2->(DbSetOrder(3))

						If !lFA430FIG .Or. (lFA430FIG .And. !Empty(cCGC))
							SA2->(DbSeek(xFilial("SA2")+cCGC))
						EndIf

						If lFA430FIG //Ponto de entrada para permitir alteracoes no CGC antes de posicionar o fornecedor para gravacao de dados na tabela FIG
							cCodForn := SA2->A2_COD

							cQuery := "SELECT SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_FORNECE,SE2.E2_LOJA FROM " + RetSqlName("SE2") + " SE2 "
							cQuery += "WHERE SE2.E2_IDCNAB = '" + cNumTit + "' AND SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND SE2.D_E_L_E_T_ = ' '"
							cQuery := ChangeQuery(cQuery)

							dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasTmp, .F., .T. )
							(cAliasTmp)->(DbGotop())
							cCGC := ExecBlock( "FA430FIG", .F., .F., { cCGC, cCodForn,(cAliasTmp)->E2_PREFIXO,cNumTit,(cAliasTmp)->E2_PARCELA})
							(cAliasTmp)->(DbCloseArea())
						EndIf

						//Grava arquivo de conciliação DDA
						RecLock("FIG",.T.)
						FIG->FIG_FILIAL	:= xFilial("FIG")
						FIG->FIG_DATA	:= dDataBase
						FIG->FIG_FORNEC	:= SA2->A2_COD
						FIG->FIG_LOJA	:= SA2->A2_LOJA
						FIG->FIG_NOMFOR	:= SA2->A2_NREDUZ
						FIG->FIG_TITULO	:= cNumTit
						FIG->FIG_TIPO	:= cEspecie
						FIG->FIG_VENCTO	:= dBaixa
						FIG->FIG_VALOR	:= nValPgto
						FIG->FIG_CONCIL	:= "2"
						FIG->FIG_CNPJ	:= cCGC
						FIG->FIG_CODBAR	:= cCodBar
						FIG->(MsUnlock())
					Endif

					If lStatusTCB // Monitoramento TCB
						If !lAgendado
							If Ascan(aBorderos,SE2->E2_NUMBOR) == 0
								Aadd(aBorderos, SE2->E2_NUMBOR)
								Aadd(aTCBStatus, "2")	//Processado
							EndIf
						Else
							//Se algum titulo nao foi processado, nao atualiza status
							nX := Ascan(aBorderos,SE2->E2_NUMBOR)
							If (nX := Ascan(aBorderos,SE2->E2_NUMBOR)) == 0 
								Aadd(aBorderos, SE2->E2_NUMBOR)
								Aadd(aTCBStatus, "0")	//Transmitido
							ElseIf aTCBStatus[nX] == "2"
								aTCBStatus[nX] := "0"
							EndIf
						EndIf
					EndIf

					//Ponto de entrada para gravar na tabela fig a filial pertecente ao cnpj da linha header contido do arquivo .ret
					If lF430GRAFIL
						aAreaCorr := GetArea()
						DbSelectArea("SM0")
						SM0->(DbGoTop())

						While SM0->(!Eof()) .And. !Empty(cCGCFilHeader)
							If (cCGCFilHeader == SM0->M0_CGC)
								Exit
							EndIf
							SM0->( DbSkip() )
						EndDo

						ExecBlock( "F430GRAFIL", .F., .F., SM0->M0_CODFIL)
						RestArea(aAreaCorr)
					EndIf

					//Integracao protheus X tin
					If lIntEAI080
						ALTERA := .T.
						INCLUI := .F.
						FwIntegDef( 'FINA080' )
					Endif
				EndIf

				nLidos += nBloco
			EndDo

			// Atualiza status do TCB
			If lBaixou .and. (nBorderos := Len(aBorderos)) > 0 .and. Len(aTCBStatus) == nBorderos
				DbSelectArea("FWO")
				FWO->(DbSetOrder(4))
				For nX := 1 to nBorderos
					If FWO->(DbSeek( xFilial("FWO")+aBorderos[nX] ))
						RecLock("FWO",.F.)
						FWO->FWO_STATUS := aTCBStatus[nX]
						FWO->(MsUnlock())
					EndIf
				Next nX
			EndIf

			cFilAnt := cFilOrig

			If lPadrao .And. lContabiliza .And. lCabec
				dbSelectArea("SE2")
				SE2->(DbGoTo(0))
				SE5->(DbGoTo(0))
				FK2->(DbGoTo(0))

				VALOR      := nTotAger
				ABATIMENTO := 0
				nTotal     += DetProva( nHdlPrv, cPadrao, "FINA430" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )

				RodaProva(nHdlPrv, nTotal)

				//Envia para Lancamento Contabil
				cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, mv_par01 == 1, mv_par02 == 1, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/)
				aFlagCTB := {}
			EndIf

			//Ponto de entrada para renomear arquivo de retorno
			IF (ExistBlock("FA430REN"))
				FCLOSE(nHdlBco)
				ExecBlock("FA430REN",.f.,.f.)
			Endif

			// Atualiza os dados da multa pelo SIGAFIN, quando feito retorno pagamento.
			If FindFunction( "NGBAIXASE2" ) .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S' //Se houver integração entre os módulos Manutenção de Ativos e Financeiro
				NGBAIXASE2(1)
			Endif

			//Grava no SEE o n£mero do £ltimo lote recebido e gera movimentacao bancaria
			If !Empty(cLoteFin) .and. lBxCnab
				If TRB->(Reccount()) > 0
					RecLock("SEE",.F.)
					SEE->EE_LOTECP := cLoteFin
					MsUnLock()

					dbSelectArea("TRB")
					dbGotop()

					While TRB->(!Eof())
						cFilAnt   := TRB->FILORI
						cCamposE5 := "{ {'E5_DTDIGIT', STOD('" + DTOS(TRB->DATAD) + "')}"
						cCamposE5 += ",{'E5_LOTE', '" + cLoteFin + "'} }"

						oModelMov := FWLoadModel("FINM030")							//Model de Movimento Bancário
						oModelMov:SetOperation( MODEL_OPERATION_INSERT )			//Inclusao
						oModelMov:Activate()										//Ativa o modelo de dados
						oModelMov:SetValue("MASTER","E5_GRV",   .T.)	//Informa se vai gravar SE5 ou não
						oModelMov:SetValue("MASTER","NOVOPROC", .T.)	//Informa que a inclusão será feita com um novo número de processo
						oModelMov:SetValue("MASTER","E5_CAMPOS", cCamposE5)	//Informa os campos da SE5 que serão gravados indepentes de FK5
						oSubFK5 := oModelMov:GetModel("FK5DETAIL")
						oSubFKA := oModelMov:GetModel("FKADETAIL")
						oSubFKA:SetValue("FKA_IDORIG", FWUUIDV4())
						oSubFKA:SetValue("FKA_TABORI", "FK5")

						//Informacoes do movimento
						oSubFK5:SetValue("FK5_ORIGEM", FunName())
						oSubFK5:SetValue("FK5_DATA",   If(!Empty(TRB->DATAD), TRB->DATAD, dBaixa))
						oSubFK5:SetValue("FK5_VALOR",  TRB->TOTAL)
						oSubFK5:SetValue("FK5_RECPAG", "P")
						oSubFK5:SetValue("FK5_BANCO",  TRB->BANCO)
						oSubFK5:SetValue("FK5_AGENCI", TRB->AGENCIA)
						oSubFK5:SetValue("FK5_CONTA",  TRB->CONTA)
						oSubFK5:SetValue("FK5_DTDISP", TRB->DATAD)
						oSubFK5:SetValue("FK5_HISTOR", STR0009 + " " + cLoteFin )
						oSubFK5:SetValue("FK5_MOEDA",  TRB->MOEDA)
						oSubFK5:SetValue("FK5_NATURE", TRB->NATURE)
						oSubFK5:SetValue("FK5_TPDOC",  "VL")
						oSubFK5:SetValue("FK5_FILORI", TRB->FILORI)
						oSubFK5:SetValue("FK5_LOTE",   cLoteFin)

						If SpbInUse()
							oSubFK5:SetValue( "FK5_MODSPB", "1")
						Endif

						If oModelMov:VldData()
							oModelMov:CommitData()
							SE5->(dbGoto(oModelMov:GetValue("MASTER", "E5_RECNO")))
						Else
							lRet := .F.
							cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[6])
							Help( ,,"M030_FA430MOV",,cLog, 1, 0 )
						Endif

						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov := Nil
						oSubFK5 := Nil
						oSubFKA := Nil

						//Atualiza saldo bancario
						AtuSalBco(TRB->BANCO, TRB->AGENCIA, TRB->CONTA, SE5->E5_DATA, SE5->E5_VALOR, "-")
						TRB->(dbSkip())
					Enddo
				Endif
			EndIf
		End Transaction

		If(_oFina430 <> NIL)
			_oFina430:Delete()
			_oFina430 := NIL
		EndIf

		VALOR := 0
		dbSelectArea( cAlias )
		dbGoTo(nSavRecno)

		IF lF430COMP
			ExecBlock("F430COMP",.f.,.f.)
		EndIF
	EndIf

	cFilAnt := cFilOrig

Return .F.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fA430Par  ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Aciona parametros do Programa                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fA430Par()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function fA430Par()

Pergunte( "AFI430" )

MV_PAR03 := UPPER(MV_PAR03)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ChangDate ³ Autor ³ Wagner Xavier         ³ Data ³ 23/06/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Converte um string data para o formato ddmmaa de acordo com ³±±
±±³          ³um determionado tipo passado para a função.                 ³±±
±±³          ³Tipo 1 - ddmmaa                                             ³±±
±±³          ³Tipo 2 - mmddaa                                             ³±±
±±³          ³Tipo 3 . aammdd                                             ³±±
±±³          ³Tipo 4 - ddmmaaaa                                           ³±±
±±³          ³Tipo 5 - aaaammdd                                           ³±±
±±³          ³Tipo 6 - mmddaaaa                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function ChangDate(__cData,nPosicao)
LOCAL nPosDia:=0,nPosMes:=0,nPosAno:=0
LOCAL aSubs  := {}

// posicao do dia,mes,ano,tamanho do ano;
AADD( aSubs,{ 01,03,05,2 } )
AADD( aSubs,{ 03,01,05,2 } )
AADD( aSubs,{ 05,03,01,2 } )
AADD( aSubs,{ 01,03,05,4 } )
AADD( aSubs,{ 07,05,01,4 } )
AADD( aSubs,{ 03,01,05,4 } )

If nPosicao == 0;nPosicao++;Endif

nPosDia := aSubs[nPosicao][1]
nPosMes := aSubs[nPosicao][2]
nPosAno := aSubs[nPosicao][3]

__cData := Substr(__cData,nPosDia,2)+Substr(__cData,nPosMes,2)+Substr(__cData,nPosAno,aSubs[nPosicao][4])

If Len(__cData) == 8
	__cData := Substr(__cData,1,4)+Substr(__cData,7,2)
Endif

Return(__cData)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³Chk430File³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Checa se arquivo de TB j  foi processado anteriormente	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Chk430File()  											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Fina430													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
User Function Chk430File()

Local cFile 	:= "TB"+cNumEmp+".VRF"
Local lRet		:= .F.
Local aFiles	:= {}
Local cString
Local nTam
Local nHdlFile
Local l430Chkfile := ExistBlock("F430CHK")
Local cKeyBloq	:= 'FIN430:' + cFile

IF LOCKBYNAME(cKeyBloq,.T.,.F.)
	If l430ChkFile		// garantir que o arquivo nao seja reenviado
		Return Execblock("F430CHK",.F.,.F.)
	Endif

	If !FILE(cFile)
		nHdlFile := fCreate(cFile)
	ELSE
		// Tenta abrir o arquivo em modo de Leitura/Gravacao
		While ((nHdlFile := fOpen(cFile,FO_READWRITE))==-1 .AND. ;
				if(ExecSchedule(),.T., MsgYesNo( STR0011+cNumEmp+STR0012, STR0010 )))
		Enddo
	Endif

	If nHdlFile > 0
		nTam := TamSx1("AFI430","03")[1] // Tamanho do parametro
		xBuffer := SPACE(nTam)

		// Le o arquivo e adiciona na matriz
		While fReadLn(nHdlFile,@xBuffer,nTam)
			Aadd(aFiles, Trim(xBuffer))
		Enddo

		If ASCAN(aFiles,Trim(MV_PAR03)) > 0
			If !lExecJob //Se estiver em modo Job nao apresenta a mensagem e sempre reprocessa
				Help(" ",1,"CHK200FILE")       // Arquivo de Trans.Banc. j  processado
				//Questiona o usuário se ele deseja efetuar um reprocessamento do arquivo
				If !MsgYesNo( STR0021, STR0010 )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o log de processamento com o erro  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					ProcLogAtu("ERRO","CHK200FILE",Ap5GetHelp("CHK200FILE"))
				Else
					lRet := .T.
				EndIf
			Else
				lRet := .T.
			Endif
		Else
			fSeek(nHdlFile,0,2) // Posiciona no final do arquivo
			cString := Alltrim(mv_par03)+Chr(13)+Chr(10)
			fWrite(nHdlFile,cString)	// Grava nome do arquivo a ser processado
			lRet := .T.
		Endif
		fClose (nHdlFile)
	Else
		If ! lExecJob
			Help(" ", 1, "CHK200ERRO") // Erro na leitura do arquivo de entrada
		Else
			Aadd(aMsgSch, STR0045) // Erro na leitura do arquivo de entrada
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento com o erro  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("ERRO","CHK200ERRO",Ap5GetHelp("CHK200ERRO"))
	EndIf

	UnLockByName(cKeyBloq,.T.,.F.)
ELSE
   Help(" ", 1, "CHK200ERRO") // Erro na leitura do arquivo de entrada
ENDIF

Return lRet



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FAVerInd ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 02/05/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica existencia dos indices 19(SE1) e 13(SE2)          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function FAVerInd()

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºRotina    ³Dv_BarCodeºAutor  ³Claudio D. de Souza º Data ³  14/12/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula o digito verificador de um codigo de barras padrao  º±±
±±º          ³Febraban.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ CodBarVl2                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function DV_BarCode( cBarCode )
Local cDig
Local nPos
Local nAux := 0

For nPos := 1 To 43
	nAux += Val(SubStr(cBarCode,nPos,1)) * If( nPos<= 3, ( 5-nPos),     ;
		If( nPos<=11, (13-nPos),     ;
		If( nPos<=19, (21-nPos),     ;
		If( nPos<=27, (29-nPos),     ;
		If( nPos<=35, (37-nPos),     ;
		(45-nPos) )))))
Next
nAux := nAux % 11
cDig := If( (11-nAux)>9, 1, (11-nAux) )

Return Str(cDig,1)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FinA430T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 15.05.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function FinA430T(aParam)
	cRotinaExec := "FINA380"
	ReCreateBrow("SE2",FinWindow)
	FinA430()
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.



/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ExecSchedule³ Autor ³ Aldo Barbosa dos Santos      ³21/12/10³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Retorna se o programa esta sendo executado via schedule     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ExecSchedule()
Local lRetorno := .T.

lRetorno := IsBlind()

Return( lRetorno )

/*/
 {Protheus.doc} A460FSA2
 Aplicar Filtro na Tabela de Fornecedores (Campo reservado A2_MSBLQL)

 @author norbertom
 @since 02/02/2016
 @version 1.0
 @param nil
 @return nil
/*/
Static Function A460FSA2()
Local cFilter  := SA2->(dbFilter())
Local cFilBlq  := " !SA2->A2_MSBLQL == '1' "
Local aGetArea := GETAREA()

dbSelectArea("SA2")
If SA2->(FieldPos("A2_MSBLQL")) > 0
	If !'A2_MSBLQL' $ cFilter
		If !Empty(cFilter)
			cFilter += " .AND. "
		EndIf
		cFilter += cFilBlq
		SA2->(dbSetFilter({||&cFilter},cFilter))
	EndIf
EndIf

RESTAREA(aGetArea)
Return nil

//-------------------------------------
/*/{Protheus.doc}F430FilTit
Posiciona na filial de origem do título

@param cIdCnab, Identificador do título de retorno
@return nRecnoSE2, Recno do título a ser processado
@author Sivaldo Oliveira
@since  16/12/2019
@version 12
/*/
//-------------------------------------
Static Function F430FilTit(cIdCnab As Character) As Numeric
	Local nRecnoSE2 As Numeric
	Local lRet      As Logical

	//Inicializa variáveis
	nRecnoSE2 := 0
	lRet      := .F.

	Default cIdCnab := ""

	If !Empty(cIdCnab)
		SE2->(dbSetOrder(13))

		If !(lRet := SE2->(DbSeek(Substr(cIdCnab, 1, 10))) .And. !Empty(SE2->E2_FILORIG))
			SE2->(dbSetOrder(11))
			lRet := SE2->(DbSeek(xFilial("SE2") + Substr(cIdCnab, 1, 10))) .And. !Empty(SE2->E2_FILORIG)
		Endif

		If lRet
			If mv_par11 == 2 .And. !Empty(xFilial("SE2"))
				cFilAnt	  := SE2->E2_FILORIG
			EndIf

			nRecnoSE2 := SE2->(Recno())
		EndIf
	EndIf
Return nRecnoSE2

/*/{Protheus.doc} AjstIdCNAB
Ajusta ID CNAB caso o mesmo não possua zeros a esquerda, apenas 6 caracters.

@type  		Function
@since 		24/09/2021
@param 		cIdCNAB, character, id cnab
@return 	character, novo Id CNAB modificado com 0 a esquerda
/*/
Static Function AjstIdCNAB(cIdCNAB As Character) As Character

	Local cNovIdCNAB	As Character
	Local cSubIdCNAB	As Character
	Local cZero			As Character

	Local nLenIdCNAB	As Numeric
	Local nTamIdCNAB	As Numeric

	Default cIdCNAB		:= ""	

	cNovIdCNAB	:= ""
	cZero		:= ""
	nLenIdCNAB	:= Len(cSubIdCNAB := LTrim(cIdCNAB))
	nTamIdCNAB	:= TamSX3("E2_IDCNAB")[1]

	cZero := Replicate("0", nTamIdCNAB - nLenIdCNAB)

	cNovIdCNAB := cZero + cSubIdCNAB

Return cNovIdCNAB
