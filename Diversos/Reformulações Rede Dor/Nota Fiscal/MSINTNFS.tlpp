#INCLUDE "TOTVS.CH"
#INCLUDE "APWEBSRV.CH"
#include "Protheus.ch"
#iNCLUDE "FWMVCDEF.ch"
#include "topconn.ch"
#INCLUDE "TBICONN.CH"
#INCLUDE "FINA050.CH"



/*/{Protheus.doc} MSINTNFS
PRW Responsável por todas as operações na integração de notas fiscais dos fronts para o Protheus via barramento
Inclusão, alteração, exclusão, devolução comum e devolução de mês fechado
Esse PRW não está considerando as integrações feitas via captura de notas, já que se trata de um sistema diferente
@type function
@author Lucas Miranda de Aguiar - Miranda Solution
@since 07/05/2025
/*/

User Function MSINTNFS()

Return


/*/{Protheus.doc} MSINTNF1
Inclui, altera, deleta e devolve notas fiscais de entrada
@type function
@author Lucas Miranda de Aguiar - Miranda Solution
@since 07/05/2025
/*/
	WSService MSINTNF1 Description "Integração de Nota Fiscal de Entrada - Novo"
		WSData DocEntrada as DocumentoEntrada
		WSData DelDocEnt  as DeleteDocEnt
		WSData DevDocEnt  as DevolverDocEntrada
		WSData CancelDev  as CanDocDevolucao
		WSData cRet       as String

		WSMethod UpSertDocEntrada     Description "Inclui ou Altera uma Nota Fiscal de Entrada"
		WSMethod DeleteDocEntrada     Description "Exclui uma Nota Fiscal de Entrada"
		WSMethod DevolverDocEntrada   Description "Devolve uma Nota Fiscal de Entrada"
		WSMethod CancelarDocDevolucao Description "Cancelamento de Devolução"
	EndWSService

WSMethod UpSertDocEntrada WSReceive DocEntrada WSSend cRet WSService MSINTNF1
	Local oCabec   := ::DocEntrada:CabDocEnt
	Local oCorpo   := ::DocEntrada:ItDocEnt
	Local oParcela := ::DocEntrada:DupDocEnt

	Begin WSMethod
	::cRet := U_MSINTNF2(oCabec, oCorpo, oParcela, 3)
End WSMethod
Return .T.

WSMethod DeleteDocEntrada WSReceive DelDocEnt WSSend cRet WSService MSINTNF1
	Local oCabec := ::DelDocEnt

	Begin WSMethod
	::cRet := U_MSINTNF2(oCabec, , , 5)
End WSMethod
Return .T.

WSMethod DevolverDocEntrada WSReceive DevDocEnt WSSend cRet WSService MSINTNF1
	Local oCabec := ::DevDocEnt:CabDevDocEnt
	Local oCorpo := aSort(::DevDocEnt:ItensDevDocEnt, , , {|p1,p2| p1:cproduto + p1:cvalor  < p2:cproduto + p2:cvalor  })

	Begin WSMethod
	::cRet := U_MSINTNF3(oCabec, oCorpo)
End WSMethod
Return .T.

WSMethod CancelarDocDevolucao WSReceive CancelDev WSSend cRet WSService MSINTNF1
	Local oCabecCan   := ::CancelDev:CabCanDevDoc

	Begin WSMethod
	::cRet := U_MSINTNF4(oCabecCan, 5, 2)
End WSMethod
Return .T.


WSStruct DocumentoEntrada
	WSData CabDocEnt as CabecDocEnt
	WSData ItDocEnt  as Array of ItensDocEnt
	WSData DupDocEnt as Array of Duplicatas
EndWSStruct

WSStruct CabecDocEnt
	WSData cBasCOFI as String
	WSData cBasCSLL as String
	WSData cBasECF3 as String
	WSData cBasECID as String
	WSData cBasECPM as String
	WSData cBasEFD  as String
	WSData cBasEFMP as String
	WSData cBasEICM as String
	WSData cBasEINS as String
	WSData cBasEIPI as String
	WSData cBasEPS3 as String
	WSData cBasIMP1 as String
	WSData cBasIMP2 as String
	WSData cBasIMP3 as String
	WSData cBasIMP4 as String
	WSData cBasIMP5 as String
	WSData cBasIMP6 as String
	WSData cBasPIS  as String
	WSData cBRICMS  as String
	WSData cCHVNFE  as String
	WSData cCIF     as String
	WSData cCODNFE  as String
	WSData cCONTSOC as String
	WSData cDESCONT as String
	WSData cDESPESA as String
	WSData cDOC     as String
	WSData cDTDIGIT as String
	WSData cEMISSAO as String
	WSData cESPECIE as String
	WSData cEST     as String
	WSData cFILREG  as String
	WSData cFOB_R   as String
	WSData cFORNECE as String
	WSData cFRETE   as String
	WSData cHORA    as String
	WSData cICMS    as String
	WSData cICMSRET as String
	WSData cINSS    as String
	WSData cIPI     as String
	WSData cIRRF    as String
	WSData cISS     as String
	WSData cLOJA    as String
	WSData cMENNOTA as String
	WSData cNFORIG  as String
	WSData cOPERAC  as String
	WSData cPREFIXO as String
	WSData cRECBMTO as String
	WSData cSEGURO  as String
	WSData cSERIE   as String
	WSData cSERORIG as String
	WSData cSTATUS  as String
	WSData cTIPO    as String
	WSData cVALBRUT as String
	WSData cVALCF3  as String
	WSData cVALCOFI as String
	WSData cVALCSLL as String
	WSData cVALEMB  as String
	WSData cVALFMP  as String
	WSData cVALICM  as String
	WSData cVALIMP1 as String
	WSData cVALIMP2 as String
	WSData cVALIMP3 as String
	WSData cVALIMP4 as String
	WSData cVALIMP5 as String
	WSData cVALIMP6 as String
	WSData cVALIPI  as String
	WSData cVALIRF  as String
	WSData cVALMERC as String
	WSData cVALPIS  as String
	WSData cVALPS3  as String
	WSData cVLCIDE  as String
	WSData cVLCPM   as String
	WSData cXCONSIG as String
	WSData CXTITFRO as String
EndWSStruct

WSStruct ItensDocEnt
	WSData cABATMAT as String
	WSData cALIQCF3 as String
	WSData cALQCIDE as String
	WSData cALIQINS as String
	WSData cALIQIRR as String
	WSData cALIQISS as String
	WSData cALIQPS3 as String
	WSData cALIQSOL as String
	WSData cALQCOF  as String
	WSData cALQCSL  as String
	WSData cALQFMP  as String
	WSData cALQIMP1 as String
	WSData cALQIMP2 as String
	WSData cALQIMP3 as String
	WSData cALQIMP4 as String
	WSData cALQIMP5 as String
	WSData cALQIMP6 as String
	WSData cALQPIS  as String
	WSData cBasECF3 as String
	WSData cBasECID as String
	WSData cBasECOF as String
	WSData cBasECSL as String
	WSData cBasEFMP as String
	WSData cBasEICM as String
	WSData cBasEINS as String
	WSData cBasEIPI as String
	WSData cBasEIRR as String
	WSData cBasEISS as String
	WSData cBasEPIS as String
	WSData cBasEPS3 as String
	WSData cBasIMP1 as String
	WSData cBasIMP2 as String
	WSData cBasIMP3 as String
	WSData cBasIMP4 as String
	WSData cBasIMP5 as String
	WSData cBasIMP6 as String
	WSData cBRICMS  as String
	WSData cCF      as String
	WSData cCFPS    as String
	WSData cCLasFIS as String
	WSData cCOD     as String
//	WSData cCONTA   as String
	WSData cCRDZFM  as String
	WSData cCUSTO   as String
	WSData cDESC    as String
	WSData cDESCICM as String
	WSData cDESPESA as String
	WSData cESTCRED as String
	WSData cICMSCOM as String
	WSData cICMSDIF as String
	WSData cICMSRET as String
	WSData cIPI     as String
	WSData cITEM    as String
	WSData cITEMORI as String
	WSData cITEMPC  as String
	WSData cLOCAL   as String
	WSData cMARGEM  as String
	WSData cNFORI   as String
	WSData cOPER    as String
	WSData cPEDIDO  as String
	WSData cPICM    as String
	WSData cQTDEDEV as String
	WSData cQTDPEDI as String
	WSData cQUANT   as String
	WSData cSEGURO  as String
	WSData cSERIORI as String
	WSData cTES     as String
	WSData cTIPO    as String
	WSData cTOTAL   as String
	WSData cUM      as String
	WSData cVALACRS as String
	WSData cVALCF3  as String
	WSData cVALCOF  as String
	WSData cVALCSL  as String
	WSData cVALDESC as String
	WSData cVALDEV  as String
	WSData cVALFMP  as String
	WSData cVALFRE  as String
	WSData cVALICM  as String
	WSData cVALIMP1 as String
	WSData cVALIMP2 as String
	WSData cVALIMP3 as String
	WSData cVALIMP4 as String
	WSData cVALIMP5 as String
	WSData cVALIMP6 as String
	WSData cVALINS  as String
	WSData cVALIPI  as String
	WSData cVALIRR  as String
	WSData cVALISS  as String
	WSData cVALPIS  as String
	WSData cVALPS3  as String
	WSData cVLCIDE  as String
	WSData cVUNIT   as String
	WSData cXDTVALI as String
	WSData cXLOTECT as String
	WSData cXSETOR  as String
	WSData cXCONSIG as String
EndWSStruct

WSStruct Duplicatas
	WSData cEMISSAO as String
	WSData cFORNECE as String
	WSData cLOJA    as String
	WSData cMOEDA   as String
	WSData cNOMFOR  as String
	WSData cNUM     as String
	WSData cPARCELA as String
	WSData cPREFIXO as String
	WSData cSALDO   as String
	WSData cTIPO    as String
	WSData cVALOR   as String
	WSData cVENCORI as String
	WSData cVENCREA as String
	WSData cVENCTO  as String
	WSData cVLCRUZ  as String
EndWSStruct

WSStruct DeleteDocEnt
	WSData cDOC     as String
	WSData cFILREG  as String
	WSData cFORNECE as String
	WSData cLOJA    as String
	WSData cSERIE   as String
EndWSStruct

WSStruct DevolverDocEntrada
	WSData CabDevDocEnt   as CabDevolveDocEnt
	WSData ItensDevDocEnt as Array of ItensDevolveDocEnt
EndWSStruct

WSStruct CabDevolveDocEnt
	WSData cDOC      as String
	WSData cFILREG   as String
	WSData cFORNECE  as String
	WSData cLOJA     as String
	WSData cSERIE    as String
	WsData cDTDEV    as String
	WsData cTAGDEV   as String
EndWSStruct

WSStruct ItensDevolveDocEnt
	WSData cPRODUTO as String
	WSData cPRCVEN  as String
	WSData cQTDVEN  as String
	WSData cVALOR   as String
	WSData cITEMORI as String
EndWSStruct

WSStruct CanDocDevolucao
	WSData CabCanDevDoc as CabCancelDevDoc
EndWSStruct

WSStruct CabCancelDevDoc
	WSData cDOC      as String
	WSData cFILREG   as String
	WSData cFORNECE  as String
	WSData cLOJA     as String
	WSData cSERIE    as String
	WsData cDTDEV    as String
	WSData cTAGDEV   as String
EndWSStruct


#INCLUDE "totvs.ch"
#INCLUDE "TBICONN.CH"

/*/{Protheus.doc} MSINTNF2
Função responsável pela inclusão, alteração e deleção de notas fiscais
@type function
@author Lucas Miranda de Aguiar - Miranda Solution
@since 07/05/2025
/*/

User Function MSINTNF2(oCabec, oCorpo, oParcela, nOperac)

	Local aCabec	:= {}							as Array
	Local aConv     := {}							as Array
	Local aExcNF	:= {}							as Array
	Local aExcTit	:= {}							as Array
	Local aImp		:= {}							as Array
	Local aItens	:= {}							as Array
	Local aLinha	:= {}							as Array
	Local aLog 		:= {}							as Array
	Local aTitulo 	:= {}							as Array
	Local bBlock 	:= ErrorBlock({|e|ChkErr(e)})	as Variant
	Local cFilDoc 	:= ""							as Character
	Local cRet 		:= "ERRO|"						as Character
	Local cXID		:= U_GetIntegID()				as Character
	Local cXIDOld	:= ""							as Character
	Local cConteudo := ""							as Character
	Local cIndKey   := ''							as Character
	Local lRet 	    := .T.							as Logical
	Local nTamDoc   := TamSX3("F1_DOC")[1]			as Numeric
	Local nTamFor   := TamSX3("F1_FORNECE")[1]		as Numeric
	Local nTamLoja  := TamSX3("F1_LOJA")[1]			as Numeric
	Local nTamSer   := TamSX3("F1_SERIE")[1]		as Numeric
	Local nX        := 0							as Numeric
	Local nY	    := 0							as Numeric
	Local nZ 	    := 0							as Numeric
	Local nLenParc  := 0							as Numeric


	Private cNomeArq	:= AllTrim(oCabec:cDoc) + AllTrim(oCabec:cSerie) + AllTrim(oCabec:cFornece) + AllTrim(oCabec:cLoja) + AllTrim(cXID)+".txt"
	Private cErrorL			:= ""
	Private CUSERNAME 		:= "INTNF"
	Private _cCodServ := ""
	Private cFilSBZ   := AllTrim(oCabec:cFilReg)

	Private lAutoErrNoFile 	:= .T.
	Private lMsErroAuto 		:= .F.

	Private dDtValExec       := CToD("  /  /    ")
	Private dDigita := ""


	Private nRegLog	:= 0

	nRegLog := U_MSLOGNFS("I",{oCabec,oCorpo,oParcela},0,{},nOperac)

	__CUSERID := "005026"

	DbSelectArea("SBZ")
	DbSetOrder(1)
	If nOperac <> 5
		For nX := 1 To Len(oCorpo)
			If DbSeek(cFilSBZ+oCorpo[nX]:cCod)
				_cCodServ := SBZ->BZ_CODISS
			Endif
		Next nX
	EndIf

	cFilDoc := Alltrim(oCabec:cFilReg)

	If Empty(cFilDoc) .Or. !ExistCpo("SM0",cEmpAnt + cFilDoc)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CFILREG"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	Else
		cFilAnt := cFilDoc
	EndIf



	If Empty(cFilDoc) .Or. !ExistCpo("SM0",cEmpAnt + cFilDoc)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CFILREG"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	Else
		cFilAnt := cFilDoc
	EndIf

	If lRet .And. Empty(oCabec:cDoc)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CDOC"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	EndIf


	If lRet .And. Empty(oCabec:cSerie)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CSERIE"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	EndIf

	If lRet .And. Empty(oCabec:cFornece)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CFORNECE"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	EndIf

	If lRet .And. Empty(oCabec:cLoja)
		lRet := .F.
		cRet += "PARAMETRO OBRIGATORIO INVALIDO: CLOJA"
		U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
	EndIf

	If nOperac == 3 .And. !Empty(oCabec:cDtDigit)
		If Empty(cToD(oCabec:cDtDigit))
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO INVALIDO: CDTDIGIT"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		Else
			dDataBase := cToD(oCabec:cDtDigit)
		EndIf
	EndIf

	cIndKey := xFilial("SF1") + '|' + Padr(oCabec:cDoc,nTamDoc) + '|' + Padr(oCabec:cSerie,nTamSer) + '|' + Padr(oCabec:cFornece,nTamFor) + '|' + Padr(oCabec:cLoja,nTamLoja)

	If lRet
		SF1->(DbSetOrder(1))
		If SF1->(DbSeek(xFilial("SF1") + Padr(oCabec:cDoc,nTamDoc) + Padr(oCabec:cSerie,nTamSer) + Padr(oCabec:cFornece,nTamFor) + Padr(oCabec:cLoja,nTamLoja)))

			//Verifica se calendario contabil esta aberto ou fechado, se fechado e exclusao, nao permite o processamento
			If nOperac == 5 .and. InvalidCTG()
				lRet := .F.
				cRet += "CALENDARIO CONTABIL FECHADO OU BLOQUEADO, EXCLUSAO DA NF DE ENTRADA NAO REALIZADA"
			Endif

			if lRet
				Begin Transaction

					cXIDOld := SF1->F1_XID
					SE2->(DBOrderNickName("EF0703301"))
					If SE2->(DbSeek(xFilial("SE2") + cXIDOld))
						While SE2->E2_FILIAL == xFilial("SE2") .And. SE2->E2_XID == cXIDOld
							aExcTit := {}
							AAdd(aExcTit,{"E2_NUM" 		,SE2->E2_NUM		,NIL})
							AAdd(aExcTit,{"E2_PREFIXO"	,SE2->E2_PREFIXO	,NIL})
							AAdd(aExcTit,{"E2_PARCELA"	,SE2->E2_PARCELA	,NIL})
							AAdd(aExcTit,{"E2_TIPO"		,SE2->E2_TIPO		,NIL})
							AAdd(aExcTit,{"E2_FORNECE"	,SE2->E2_FORNECE	,NIL})
							AAdd(aExcTit,{"E2_LOJA"		,SE2->E2_LOJA		,NIL})

							MsExecAuto({|x,y,z| FINA050(x,y,z)},aExcTit,,5)

							If lMsErroAuto
								DisarmTransaction()
								Break
							EndIf
							SE2->(DbSkip())
						EndDo
					EndIf

					AAdd(aExcNF,{"F1_DOC"    , SF1->F1_DOC    , NIL})
					AAdd(aExcNF,{"F1_SERIE"  , SF1->F1_SERIE  , NIL})
					AAdd(aExcNF,{"F1_FORNECE", SF1->F1_FORNECE, NIL})
					AAdd(aExcNF,{"F1_LOJA"   , SF1->F1_LOJA   , NIL})
					AAdd(aExcNF,{"F1_FORMUL" , SF1->F1_FORMUL , NIL})

					dDtValExec := SF1->F1_EMISSAO

					MSExecAuto({|x,y,z| MATA103(x,y,z)},aExcNF,aItens,5)

					If lMsErroAuto
						DisarmTransaction()
						Break
					EndIf

					If nOperac == 3
						lRet := CarArrayNF(oCabec,oCorpo,@aCabec,@aItens,@cRet,cXID,oParcela[1])

						If !lRet
							DisarmTransaction()
							Break
						EndIf

						dDtValExec := CToD(oCabec:cDtDigit)

						MSExecAuto({|x,y,z| MATA103(x,y,z)},aCabec,aItens,3)

						If lMsErroAuto
							DisarmTransaction()
							Break
						EndIf

						SD1->(DbSetOrder(1))
						If !SD1->(DbSeek(xFilial("SD1")+SF1->(F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)))
							EnviaEmail()
							Conout("D1 SEM FILIAL")
							Conout("CHAVE F1: " + SF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA))
							cRet += "Itens da nota fiscal não encontrados - rollback na operação."
							Conout("Nota fiscal existia anteriormente")
							U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
							DisarmTransaction()
							Break
						EndIf

						For nZ := 1 to Len(oParcela)
							nLenParc := Len(oParcela)
							aTitulo := {}
							lRet := CarArrayCP(oParcela[nZ], cXID, @cRet, @aTitulo, SD1->D1_CC, _cCodServ, nLenParc)

							If !lRet
								DisarmTransaction()
								Break
							EndIf

							If Len(aTitulo) > 0
								CUSERNAME := "Integrador"
								MsExecAuto({|x,y,z| FINA050(x,y,z)},aTitulo,,3)
								If lMsErroAuto

									DisarmTransaction()
									U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
									Break
								EndIf
							EndIf
						Next nZ
					EndIf
				End Transaction
			EndIf
		Else
			If nOperac == 5
				lRet := .F.
				cRet += "NOTA FISCAL NAO LOCALIZADA" + CRLF
			Else
				Begin Transaction

					lRet := CarArrayNF(oCabec,oCorpo,@aCabec,@aItens,@cRet,cXID,oParcela[1])

					If !lRet
						DisarmTransaction()
						Break
					EndIf

					dDtValExec := CToD(oCabec:cDtDigit)

					MSExecAuto({|x,y,z| MATA103(x,y,z)},aCabec,aItens,3)

					If lMsErroAuto
						DisarmTransaction()
						Break
					EndIf

					SD1->(DbSetOrder(1))
					If !SD1->(DbSeek(xFilial("SD1")+SF1->(F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)))
						EnviaEmail()
						Conout("D1 SEM FILIAL")
						Conout("CHAVE F1: " + SF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA))
						Conout("Nota fiscal não existia anteriormente")
						cRet += "Itens da nota fiscal não encontrados - rollback na operação."

						DisarmTransaction()
						U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
						Break
					EndIf

					For nZ := 1 to Len(oParcela)

						nLenParc := Len(oParcela)
						aTitulo := {}
						lRet := CarArrayCP(oParcela[nZ], cXID, @cRet, @aTitulo, SD1->D1_CC, _cCodServ, nLenParc)

						If !lRet
							DisarmTransaction()
							Break
						EndIf

						If Len(aTitulo) > 0
							CUSERNAME := "Integrador"
							MsExecAuto({|x,y,z| FINA050(x,y,z)},aTitulo,,3)
							If lMsErroAuto
								DisarmTransaction()
								Break
							EndIf
						EndIf
					Next nZ

				End Transaction
			EndIf
		EndIf

		CUSERNAME := "INTNF"
		//ErrorBlock(bBlock)

		If lMsErroAuto
			cRet += "INCONSISTENCIA DE ROTINA AUTOMATICA | " + CRLF
			lRet := .F.
			aLog := GetAutoGRLog()
			For nY := 1 To Len(aLog)
				cRet += aLog[nY] + CRLF
			Next nY
		EndIf

		If !Empty(cErrorL)
			lRet := .F.
			cRet += "ERRO DE PROGRAMACAO | " + CRLF + cErrorL
		EndIf

		If !lMsErroAuto .And. lRet

			cRet := "OK|ID: " + cXID
			U_MSLOGNFS("A",{},nRegLog,{cRet,1},nOperac)
		Else
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		EndIf
	EndIf

	dDataBase := Date()
	ErrorBlock(bBlock)
Return cRet


/*/{Protheus.doc} CarArrayNF
Função responsável pela montagem do array para inclusão da nota fiscal via execauto
@type function
@author anieli.rodrigues
@since 03/02/2017
@version 12.7
@param oCabec, object, Dados do cabeçalho da nota fiscal
@param oCorpo, object, Dados do item da nota fiscal
@param aCabec, array, Variavel para montagem do array de cabeçalho (referencia)  
@param aItens, array, Variavel para montagem do array de itens (referencia)
@param cRet, caractere, Variavel para armazenar mensagem de erro (referencia)
@param cXID, caractere, ID unico reservado para a integração
@project MAN0000007423041_EF_033
@return lRet
/*/

Static Function CarArrayNf(oCabec,oCorpo,aCabec,aItens,cRet,cXID,oParcela)

	Local aConv    	  := {}								as Array
	Local aItens   	  := {}								as Array
	Local aLinha   	  := {}								as Array
	Local nTamDoc  	  := TamSX3("F1_DOC")[1]			as Numeric
	Local nTamFor  	  := TamSX3("F1_FORNECE")[1]		as Numeric
	Local nTamLoja 	  := TamSX3("F1_LOJA")[1]			as Numeric
	Local nTamProd 	  := TamSX3("D1_COD")[1]			as Numeric
	Local nTamSer  	  := TamSX3("F1_SERIE")[1]			as Numeric
	Local nX       	  := 0								as Numeric
	Local nDespesa 	  := 0								as Numeric
	Local nVlDescItm  := 0								as Numeric
	Local _nAliq      := 0								as Numeric
	Local _nValiss    := 0								as Numeric
	Local lFixa 	  := .F.							as Logical
	Local lRet     	  := .T.							as Logical
	Local lParam      := .F.							as Logical
	Local dData 	  := StoD("")						as Date
	Local cTESIntNor  := SuperGetMV("FS_TESINOR",,"")	as Character
	Local _cTESPar    := ""								as Character
	Local _cTotal     := ""								as Character
	Local cTESIntCon  := SuperGetMV("FS_TESICON",,"")	as Character
	Local _cTESFor    := SuperGetMV("FS_TESSERV")		as Character
	Local _cCodFor    := SuperGetMV("FS_FORSERV")		as Character

	Private aPedidos := {}								as Array

	If Empty(cTESIntNor)
		lRet := .F.
		cRet += "PARAMETRO FS_TESINOR NÃO CONFIGURADO (TES DE INTEGRAÇÃO MOVIMENTO NORMAL)"
		Return lRet
	EndIf

	If Empty(cTESIntCon)
		lRet := .F.
		cRet += "PARAMETRO FS_TESICON NÃO CONFIGURADO (TES DE INTEGRAÇÃO MOVIMENTO CONSIGNADO)"
		Return lRet
	EndIf

	dDigita := oCabec:cDtDigit

	AAdd(aCabec,{"F1_TIPO" 		,oCabec:cTipo})
	AAdd(aCabec,{"F1_FORMUL" 	,"N"})
	AAdd(aCabec,{"F1_DOC"    	,Padr(oCabec:cDoc,nTamDoc)})
	AAdd(aCabec,{"F1_SERIE"  	,Padr(oCabec:cSerie,nTamSer)})
	AAdd(aCabec,{"F1_EMISSAO"	,CtoD(oCabec:cEmissao)})
	AAdd(aCabec,{"F1_FORNECE"	,Padr(oCabec:cFornece,nTamFor)})
	AAdd(aCabec,{"F1_LOJA"   	,Padr(oCabec:cLoja,nTamLoja)})
	AAdd(aCabec,{"F1_ESPECIE"	,oCabec:cEspecie})
	AAdd(aCabec,{"F1_EST" 		,oCabec:cEst})
	AAdd(aCabec,{"F1_CHVNFE" 	,oCabec:cChvNfe})
	AAdd(aCabec,{"F1_NFORIG" 	,oCabec:cNfOrig})
	AAdd(aCabec,{"F1_SERORIG" 	,oCabec:cSerOrig})
	AAdd(aCabec,{"F1_HORA" 		,oCabec:cHora})
	AAdd(aCabec,{"F1_FOB_R" 	,Iif(Empty(Val(oCabec:cFob_R)),0,Val(oCabec:cFob_R))})
	AAdd(aCabec,{"F1_CIF" 		,Iif(Empty(Val(oCabec:cCif)),0,Val(oCabec:cCif))})
	AAdd(aCabec,{"F1_RECBMTO" 	,cToD(oCabec:cRecbmto)})
	AAdd(aCabec,{"F1_CODNFE" 	,oCabec:cCodNfe})
	AAdd(aCabec,{"F1_CHVNFE" 	,oCabec:cChvNfe})
	AAdd(aCabec,{"F1_MENNOTA" 	,oCabec:cMenNota})
	AAdd(aCabec,{"F1_XCONSIG"	,oCabec:cXConsig})
	AAdd(aCabec,{"F1_XTITFRO"	,oCabec:cXTitFro})
	AAdd(aCabec,{"F1_XID" 		,cXID})
	AAdd(aCabec,{"F1_FRETE"  	,Iif(Empty(Val(oCabec:cFRETE)),0,Val(oCabec:cFRETE))})
	AADD(aCabec,{"F1_XDTEXCE"   ,"2"})
	AADD(aCabec,{"F1_XDTORIG"	,cToD(oParcela:cVencto)})

	If Posicione("SA2",1,xFilial("SA2")+Padr(oCabec:cFornece,nTamFor)+Padr(oCabec:cLoja,nTamLoja),"SA2->A2_XDTFIX") == "1"
		dData := U_DTFORNFIX(cToD(oParcela:cVencto),"",1,dDigita)
		lFixa := .T.
	EndIf

	U_F07PADR(aCabec)

	DbSelectArea("SC7")
	SC7->(DbSetOrder(1))
	For nX := 1 To Len(oCorpo)

		SC7->(DbSeek(xFilial("SC7")+oCorpo[nX]:cPedido+oCorpo[nX]:cItemPC))
		AADD(aPedidos,{SC7->C7_QUANT,SC7->C7_QUJE,SC7->(RECNO())})

		aConv := U_F07024X(Padr(oCorpo[nX]:cCod,nTamProd),cFilAnt,Val(oCorpo[nX]:cQUANT),1,2,oCorpo[nX]:cUM)

		If !Empty(aConv[3])
			lRet := .F.
			cRet += aConv[3]
			Exit
		EndIf

		If Empty(oCorpo[nX]:cITEM)
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO NAO INFORMADO: CITEM"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
			Exit
		EndIf

		If Empty(oCorpo[nX]:cPedido)
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO NAO INFORMADO: CPEDIDO"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
			Exit
		EndIf

		If Empty(oCorpo[nX]:cItemPC)
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO NAO INFORMADO: CITEMPC"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
			Exit
		EndIf

		SC7->(DbSetOrder(01))


		If _cCodFor == Padr(oCabec:cFornece,nTamFor)
			lParam := .T.
		EndIf

		If lParam

			DbSelectArea("SBZ")
			DbSetOrder(1)
			If DbSeek(cFilSBZ+oCorpo[nX]:cCod)
				_nAliq := SBZ->BZ_ALIQISS
			Endif

			_cTotal := Val(oCorpo[nX]:cTOTAL)


			_nValiss := (_nAliq / 100) * _cTotal

		Else


			If  oCorpo[nX]:cXCONSIG == "1"
				_cTESFor := cTESIntCon
			Else
				_cTESFor := cTESIntNor
			EndIf


			If Empty(oCorpo[nX]:cAliqISS)
				_nAliq := 0
			Else
				_nAliq := (oCorpo[nX]:cAliqISS)
			EndIf

			If Empty(oCorpo[nX]:cBaseISS)
				_cTotal := 0
			Else
				_cTotal := oCorpo[nX]:cBaseISS
			EndIf

			If Empty(oCorpo[nX]:cValISS)
				_nValiss := 0
			Else
				_nValiss := oCorpo[nX]:cValISS
			EndIf

		EndIf


		aLinha := {}

		AAdd(aLinha,{"D1_ITEM"   , oCorpo[nX]:cITEM															,Nil})
		AAdd(aLinha,{"D1_COD"    , oCorpo[nX]:cCod															,Nil})
		AAdd(aLinha,{"D1_PEDIDO" , oCorpo[nX]:cPedido														,Nil})
		AAdd(aLinha,{"D1_ITEMPC" , oCorpo[nX]:cItemPC														,Nil})
		AAdd(aLinha,{"D1_UM"     , aConv[2]																	,Nil})
		AAdd(aLinha,{"D1_QUANT"  , aConv[1]																	,Nil})
		AAdd(aLinha,{"D1_VUNIT"  , Val(oCorpo[nX]:cTOTAL)/aConv[1]											,Nil})
		AAdd(aLinha,{"D1_TOTAL"  , Val(oCorpo[nX]:cTOTAL)													,Nil})
		AAdd(aLinha,{"D1_SEGURO" , Iif(Empty(Val(oCorpo[nX]:cSeguro)),0,	Val(oCorpo[nX]:cSeguro))		,Nil})
		AAdd(aLinha,{"D1_VALDESC", Iif(Empty(Val(oCorpo[nX]:cValDesc)),0,Val(oCorpo[nX]:cValDesc))			,Nil})
		AAdd(aLinha,{"D1_TES"    , _cTESFor				                                                    ,Nil})
		If !Empty(oCorpo[nX]:cCF)
			AAdd(aLinha,{"D1_CF" , oCorpo[nX]:cCF															,Nil})
		EndIf
		AAdd(aLinha,{"D1_LOCAL"  , oCorpo[nX]:cLocal														,Nil})
		AAdd(aLinha,{"D1_NFORI"  , oCorpo[nX]:cNfOri														,Nil})
		AAdd(aLinha,{"D1_SERIORI", oCorpo[nX]:cSeriOri														,Nil})
		AAdd(aLinha,{"D1_ITEMORI", oCorpo[nX]:cItemOri														,Nil})
		AAdd(aLinha,{"D1_CUSTO"  , Iif(Empty(Val(oCorpo[nX]:cCusto)),0,Val(oCorpo[nX]:cCusto))				,Nil})
		AAdd(aLinha,{"D1_QTDPEDI", Iif(Empty(Val(oCorpo[nX]:cQtdPedi)),0,Val(oCorpo[nX]:cQtdPedi))			,Nil})
		AAdd(aLinha,{"D1_XDTVALI", CtoD(oCorpo[nX]:cXDtVali)												,Nil})
		AAdd(aLinha,{"D1_XLOTECT", oCorpo[nX]:cXLoteCt														,Nil})
		If !Empty(oCorpo[nX]:cXSetor)
			AAdd(aLinha,{"D1_XSETOR", oCorpo[nX]:cXSetor													,Nil})
		EndIf
		AAdd(aLinha,{"D1_XCONSIG", oCorpo[nX]:cXCONSIG														,Nil})
		AAdd(aLinha,{"D1_IPI"    , Iif(Empty(Val(oCorpo[nX]:cIPI)),0,Val(oCorpo[nX]:cIPI))					,Nil})
		AAdd(aLinha,{"D1_BASEIPI", Iif(Empty(Val(oCorpo[nX]:cBaseIPI)),0,Val(oCorpo[nX]:cBaseIPI))			,Nil})
		AAdd(aLinha,{"D1_VALIPI" , Iif(Empty(Val(oCorpo[nX]:cValIPI)),0,	Val(oCorpo[nX]:cValIPI))		,Nil})
		AAdd(aLinha,{"D1_PICM"   , Iif(Empty(Val(oCorpo[nX]:cPICM)),0,Val(oCorpo[nX]:cPICM))				,Nil})
		AAdd(aLinha,{"D1_BASEICM", Iif(Empty(Val(oCorpo[nX]:cBaseICM)),0,Val(oCorpo[nX]:cBaseICM))			,Nil})
		AAdd(aLinha,{"D1_VALICM" , Iif(Empty(Val(oCorpo[nX]:cVALICM)),0,Val(oCorpo[nX]:cVALICM))			,Nil})
		AAdd(aLinha,{"D1_ESTCRED", IIf(Empty(Val(oCorpo[nX]:cEstCred)),0,Val(oCorpo[nX]:cEstCred))			,Nil})
		AAdd(aLinha,{"D1_ICMSCOM", IIf(Empty(Val(oCorpo[nX]:cICMSCom)),0,Val(oCorpo[nX]:cICMSCom))			,Nil})
		AAdd(aLinha,{"D1_VALACRS", Iif(Empty(Val(oCorpo[nX]:cValAcrs))	,0,	Val(oCorpo[nX]:cValAcrs))		,Nil})
		AAdd(aLinha,{"D1_MARGEM" , Iif(Empty(Val(oCorpo[nX]:cMargem)),0,	Val(oCorpo[nX]:cMargem))		,Nil})
		AAdd(aLinha,{"D1_ALIQSOL", Iif(Empty(Val(oCorpo[nX]:cAliqSol))	,0,	Val(oCorpo[nX]:cAliqSol))		,Nil})
		AAdd(aLinha,{"D1_BRICMS" , Iif(Empty(Val(oCorpo[nX]:cBRICMS)),0,Val(oCorpo[nX]:cBRICMS))			,Nil})
		AAdd(aLinha,{"D1_ICMSRET", Iif(Empty(Val(oCorpo[nX]:cICMSRet)),0,Val(oCorpo[nX]:cICMSRet))			,Nil})
		AAdd(aLinha,{"D1_BASEPIS", Iif(Empty(Val(oCorpo[nX]:cBasePIS)),0,Val(oCorpo[nX]:cBasePIS))			,Nil})
		AAdd(aLinha,{"D1_ALQPIS" , Iif(Empty(Val(oCorpo[nX]:cAlqPIS)),0,Val(oCorpo[nX]:cAlqPIS))			,Nil})
		AAdd(aLinha,{"D1_VALPIS" , Iif(Empty(Val(oCorpo[nX]:cValPIS)),0,	Val(oCorpo[nX]:cValPIS))		,Nil})
		AAdd(aLinha,{"D1_BASECOF", Iif(Empty(Val(oCorpo[nX]:cBaseCof)),0,Val(oCorpo[nX]:cBaseCof))			,Nil})
		AAdd(aLinha,{"D1_ALQCOF" , Iif(Empty(Val(oCorpo[nX]:cAlqCof)),0,	Val(oCorpo[nX]:cAlqCof))	 	,Nil})
		AAdd(aLinha,{"D1_VALCOF" , Iif(Empty(Val(oCorpo[nX]:cValCof)),0,Val(oCorpo[nX]:cValCof))			,Nil})
		AAdd(aLinha,{"D1_BASECSL", Iif(Empty(Val(oCorpo[nX]:cBaseCSL)),0,Val(oCorpo[nX]:cBaseCSL))			,Nil})
		AAdd(aLinha,{"D1_ALQCSL" , Iif(Empty(Val(oCorpo[nX]:cAlqCSL)),0,	Val(oCorpo[nX]:cAlqCSL))		,Nil})
		AAdd(aLinha,{"D1_VALCSL" , Iif(Empty(Val(oCorpo[nX]:cValCSL)),0,	Val(oCorpo[nX]:cValCSL))		,Nil})
		AAdd(aLinha,{"D1_BASIMP6", Iif(Empty(Val(oCorpo[nX]:cBasImp6)),0,Val(oCorpo[nX]:cBasImp6)) 			,Nil})
		AAdd(aLinha,{"D1_ALQIMP6", Iif(Empty(Val(oCorpo[nX]:cAlqImp6)),0,Val(oCorpo[nX]:cAlqImp6))			,Nil})
		AAdd(aLinha,{"D1_VALIMP6", Iif(Empty(Val(oCorpo[nX]:cValImp6)),0,Val(oCorpo[nX]:cValImp6))			,Nil})
		AAdd(aLinha,{"D1_BASIMP5", Iif(Empty(Val(oCorpo[nX]:cBasImp5)),0,Val(oCorpo[nX]:cBasImp5)) 			,Nil})
		AAdd(aLinha,{"D1_ALQIMP5", Iif(Empty(Val(oCorpo[nX]:cAlqImp5)),0,Val(oCorpo[nX]:cAlqImp5))			,Nil})
		AAdd(aLinha,{"D1_VALIMP5", Iif(Empty(Val(oCorpo[nX]:cValImp5)),0,Val(oCorpo[nX]:cValImp5))			,Nil})
		AAdd(aLinha,{"D1_BASEIRR", Iif(Empty(Val(oCorpo[nX]:cBaseIRR)),0,Val(oCorpo[nX]:cBaseIRR))			,Nil})
		AAdd(aLinha,{"D1_ALIQIRR", Iif(Empty(Val(oCorpo[nX]:cAliqIRR)),0,Val(oCorpo[nX]:cAliqIRR))			,Nil})
		AAdd(aLinha,{"D1_VALIRR" , Iif(Empty(Val(oCorpo[nX]:cValIRR)),0,	Val(oCorpo[nX]:cValIRR))		,Nil})
		AAdd(aLinha,{"D1_ABATMAT", Iif(Empty(Val(oCorpo[nX]:cAbatMat)),0,Val(oCorpo[nX]:cAbatMat))			,Nil})
		AAdd(aLinha,{"D1_BASEISS", _cTotal			                                                        ,Nil})
		AAdd(aLinha,{"D1_ALIQISS", _nAliq			                                                        ,Nil})
		AAdd(aLinha,{"D1_VALISS" , _nValiss	                                                                ,Nil})
		AAdd(aLinha,{"D1_BASEINS", Iif(Empty(Val(oCorpo[nX]:cBaseINS)),0,Val(oCorpo[nX]:cBaseINS))			,Nil})
		AAdd(aLinha,{"D1_ALIQINS", Iif(Empty(Val(oCorpo[nX]:cAliqINS)),0,Val(oCorpo[nX]:cAliqINS))			,Nil})
		AAdd(aLinha,{"D1_VALINS" , Iif(Empty(Val(oCorpo[nX]:cValINS)),0,Val(oCorpo[nX]:cValINS))			,Nil})
		AAdd(aLinha,{"D1_ALIQCF3", Iif(Empty(Val(oCorpo[nX]:cAliqCF3)),0,Val(oCorpo[nX]:cAliqCF3))			,Nil})
		AAdd(aLinha,{"D1_BASECF3", Iif(Empty(Val(oCorpo[nX]:cBasePS3)),0,Val(oCorpo[nX]:cBasePS3))			,Nil})
		AAdd(aLinha,{"D1_VALCF3" , Iif(Empty(Val(oCorpo[nX]:cValCF3)),0,Val(oCorpo[nX]:cValCF3)) 			,Nil})
		AAdd(aLinha,{"D1_CRDZFM" , Iif(Empty(Val(oCorpo[nX]:cCrdZFM)),0,Val(oCorpo[nX]:cCrdZFM))			,Nil})
		If lFixa
			AAdd(aLinha,{"D1_XPRIVEN" , dData			,Nil})
		EndIf
		nVlDescItm := nVlDescItm + Iif(Empty(Val(oCorpo[nX]:cValDesc)),0,Val(oCorpo[nX]:cValDesc))

		U_F07PADR(aLinha)

		AAdd(aItens,aLinha)

	Next nX

	AAdd(aCabec,{"F1_DESPESA"	,VAL(oCabec:cDespesa)})
	AAdd(aCabec,{"F1_DESCONT"   ,VAL(oCabec:cDescont) + nVlDescItm })

Return lRet

/*/{Protheus.doc} CarArrayCP
Função responsável pela montagem do array para inclusão do contas a pagar 
@type function
@author anieli.rodrigues
@since 03/02/2017
@version 12.7
@param oParcela, object, Dados dos títulos a pagar da nota fiscal 
@param cXID, caractere, ID unico reservado para a integração)
@param cRet, caractere, Variavel para armazenar mensagem de erro (referencia)
@param aTitulo, array, Variavel para montagem do array de duplicatas (referencia)  
@project MAN0000007423041_EF_033
@return lRet 
/*/

Static Function CarArrayCp(oParcela, cXID, cRet, aTitulo, cCCusto, _cCodServ, nLen)

	Local lEmpty 		:= .T.																	as Logical
	Local lRet 			:= .T.																	as Logical
	Local nTamForn		:= TamSX3("E2_FORNECE")[1]												as Numeric
	Local nTamLoja		:= TamSX3("E2_LOJA")[1]													as Numeric
	Local nTamNum		:= TamSX3("E2_NUM")[1]													as Numeric
	Local nTamParc		:= TamSX3("E2_PARCELA")[1]												as Numeric
	Local nTamPref		:= TamSX3("E2_PREFIXO")[1]												as Numeric
	Local nTamTip 		:= TamSX3("E2_TIPO")[1]													as Numeric
	Local nX 			:= 0																	as Numeric
	Local cCodFor   	:= Padr(oParcela:cFornece,nTamForn)										as Character
	Local cLojFor   	:= Padr(oParcela:cLoja,nTamLoja)										as Character
	Local cNaturez  	:= Posicione("SA2",1,XFilial("SA2")+cCodFor+cLojFor,"A2_NATUREZ")		as Character
	Local _dVencto 		:= CTOD("//") 															as Date
	Local _dVenRea 		:= CTOD("//") 															as Date
	Local _dVenOri 		:= CTOD("//") 															as Date

	Default nLen 		:= 0

	If Empty(cNaturez)
		cNaturez := SuperGetMV("MV_2DUPNAT",,"")
	EndIf

	AAdd(aTitulo,{"E2_PREFIXO", Padr(oParcela:cPrefixo,nTamPref), Nil})
	AAdd(aTitulo,{"E2_NUM"    , Padr(oParcela:cNum,nTamNum)     , Nil})
	AAdd(aTitulo,{"E2_PARCELA", Padr(oParcela:cParcela,nTamParc), Nil})
	AAdd(aTitulo,{"E2_TIPO"   , Padr(oParcela:cTipo,nTamTip)    , Nil})
	AAdd(aTitulo,{"E2_NATUREZ", cNaturez                        , Nil})
	AAdd(aTitulo,{"E2_FORNECE", cCodFor                         , Nil})
	AAdd(aTitulo,{"E2_LOJA"   , cLojFor                         , Nil})
	AAdd(aTitulo,{"E2_EMISSAO", cToD(oParcela:cEmissao)         , Nil})
	If Posicione("SA2",1,xFilial("SA2")+cCodFor+cLojFor,"SA2->A2_XDTFIX") == "1"
		dData := U_DTFORNFIX(cToD(oParcela:cVencto),"",nLen,dDigita)
		AAdd(aTitulo,{"E2_VENCTO" , dData          , Nil})
		AAdd(aTitulo,{"E2_VENCREA", dData          , Nil})
		AAdd(aTitulo,{"E2_VENCORI", dData          , Nil})
		AAdd(aTitulo,{"E2_XDTFIX", "1"          , Nil})
	Else
		AAdd(aTitulo,{"E2_VENCTO" , DataValida(cToD(oParcela:cVencto))          , Nil})
		AAdd(aTitulo,{"E2_VENCREA", DataValida(cToD(oParcela:cVencRea))        , Nil})
		AAdd(aTitulo,{"E2_VENCORI", DataValida(cToD(oParcela:cVencOri))       , Nil})
		AAdd(aTitulo,{"E2_XDTFIX", "2"          , Nil})
	EndIf
	AAdd(aTitulo,{"E2_VALOR"  , Val(oParcela:cValor)            , Nil})
	AAdd(aTitulo,{"E2_SALDO"  , Val(oParcela:cSaldo	)           , Nil})
	AAdd(aTitulo,{"E2_MOEDA"  , Val(oParcela:cMoeda)            , Nil})
	AAdd(aTitulo,{"E2_VLCRUZ" , Val(oParcela:cVlCruz)           , Nil})
	AAdd(aTitulo,{"E2_CCUSTO" , cCCusto                         , Nil})
	AAdd(aTitulo,{"E2_XID"    , cXID                            , Nil})
	AAdd(aTitulo,{"E2_XDTORIG",cToD(oParcela:cVencto) 			, Nil})
	AAdd(aTitulo,{"E2_XDTEXCE","2"					 			, Nil})
	AAdd(aTitulo,{"E2_CODSERV", Alltrim(_cCodServ)              , Nil})
	AAdd(aTitulo,{"E2_XVLLIQ"  , Val(oParcela:cValor)            , Nil})

	U_F07PADR(aTitulo)

	For nX := 1 to Len(aTitulo)
		If !Empty(aTitulo[nx][2]) .And. aTitulo[nx][1] != "E2_XID"
			lEmpty := .F.
			Exit
		EndIf
	Next nX

	If lEmpty
		aTitulo := {}
	Else
		If Empty (cToD(oParcela:cEmissao))
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO INVALIDO: CEMISSAO"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		EndIf
		If lRet .And. Empty (cToD(oParcela:cVencto))
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO INVALIDO: CVENCTO"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		EndIf
		If lRet .And. Empty (cToD(oParcela:cVencRea))
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO INVALIDO: CVENCREA"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		EndIf
		If lRet .And. Empty (cToD(oParcela:cVencOri))
			lRet := .F.
			cRet += "PARAMETRO OBRIGATORIO INVALIDO: CVENCORI"
			U_MSLOGNFS("A",{},nRegLog,{cRet,2},nOperac)
		EndIf
	EndIf

Return lRet

/*/{Protheus.doc} ChkErr
Função para tratamento de erros 
@type function
@author anieli.rodrigues
@since 03/02/2017
@version 12.7
@param oErroArq, object, Dados do erro capturado
@project MAN0000007423041_EF_033
/*/

Static Function ChkErr(oErroArq)

	Local nI:= 0	as Numeric

	If oErroArq:GenCode > 0
		cErrorL := '(' + Alltrim(Str(oErroArq:GenCode)) + ') : ' + AllTrim(oErroArq:Description) + CRLF
	EndIf

	nI := 2

	While (!Empty(ProcName(ni)))
		cErrorL += Trim(ProcName(ni)) + "(" + Alltrim(Str(ProcLine(ni))) + ") " + CRLF
		ni ++
	End
	If Intransact()
		cErrorL +="Transacao aberta desarmada"
		DisarmTransaction()
	EndIf
	U_MSLOGNFS("A",{},nRegLog,{cErrorL,2},2)
	cRetErr := "ERRO| " + cErrorL
	//Break
Return

/*/{Protheus.doc} InvalidCTG
Verifica se o calendario contabil esta fechado ou bloqueado a partir da F1 posicionada
@type function
@author Thiago Pereira
@since 20/05/2019
@version 12.7
@param 
@project MAN0000007423041_EF_033
/*/
Static Function InvalidCTG()
	Local lClosed := .F.								 	as Logical
	Local cExerc := CVALTOCHAR(YEAR(SF1->(F1_DTDIGIT)))		as Character
	Local cPeriod := STRZERO(MONTH(SF1->(F1_DTDIGIT)),2)	as Character

	DbSelectArea("CTG")
	CTG->(DbSetOrder(4))
	If CTG->(MsSeek(xFilial("CTG") + cExerc + cPeriod))
		lClosed := CTG->CTG_STATUS $ "2|4" //Status fechado ou bloqueado
	EndIf
Return lClosed



//-------------------------------------------------------------------
/*/{Protheus.doc} MSLOGNFS()
Gera LOG personalizado na integração de Notas Fiscais
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------

/*/
	nOperac 1 - Devolução comum
	nOperac 2 - Cancelamento devolução comum
	nOperac 3 - Inclusão NF
	nOperac 4 - Devolução mês fechado
	nOperac 5 - Deleção NF
	nOperac 6 - Cancelamento devolução mês fechado

/*/

User Function MSLOGNFS(cOper,aXml,nRec,aInfo,nOperac)

	Local aArea := GetArea()
	Local cFilInt := ""
	Local cNumNf  := ""
	Local cSerNf  := ""
	Local cFornNF := ""
	Local cLojFrn := ""
	Local cIProc  := ""
	Local cJson   := ""
	Local cTipo   := ""
	Local cParc   := ""


	Default cOper := "A"
	Default aXml := {}
	Default nRec := 0
	Default aInfo := {}
	Default nOperac := 0

	//Inclusão NF
	If cOper == "I" .And. nOperac == 3

		cFilInt := aXml[1]:CFILREG
		cNumNf  := STRZERO(val(aXml[1]:CDOC),9)
		cSerNf  := aXml[1]:cSerie + Space(TamSX3("E2_PREFIXO")[1] - Len(aXml[1]:cSerie))
		cFornNF := aXml[1]:CFORNECE
		cLojFrn := aXml[1]:CLOJA
		cTipo   := aXml[1]:cTipo
		cParc   := aXml[3][1]:cParcela + Space(TamSX3("E2_PARCELA")[1] - Len(aXml[3][1]:cParcela))
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_PARCEL := cParc
		P50->P50_TIPO   := cTipo
		P50->P50_OPER   := fGetOper(cFilInt+cSerNf+cNumNf+cParc+cTipo+cFornNf+cLojFrn)
		P50->(MsUnLock())

		nRec := P50->(RECNO())

		//Deleção NF
	ElseIf cOper == "I" .And. nOperac == 5

		cFilInt := aXml[1]:CFILREG
		cNumNf  := aXml[1]:CDOC
		cSerNf  := aXml[1]:CSERIE
		cFornNF := aXml[1]:CFORNECE
		cLojFrn := aXml[1]:CLOJA
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_OPER   := "Deleção"
		P50->(MsUnLock())

		nRec := P50->(RECNO())

		//Devolução Comum
	ElseIf cOper == "I" .And. nOperac == 1

		cFilInt := aXml[1]:CFILREG
		cNumNf  := aXml[1]:CDOC
		cSerNf  := aXml[1]:CSERIE
		cFornNF := aXml[1]:CFORNECE
		cLojFrn := aXml[1]:CLOJA
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_OPER   := "Devolução Comum"
		P50->(MsUnLock())

		nRec := P50->(RECNO())

		//Cancelamento devlução comum
	ElseIf cOper == "I" .And. nOperac == 2

		cFilInt := aXml[1]:CFILREG
		cNumNf  := aXml[1]:CDOC
		cSerNf  := aXml[1]:CSERIE
		cFornNF := aXml[1]:CFORNECE
		cLojFrn := aXml[1]:CLOJA
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_OPER   := "Cancelamento da devolução comum"
		P50->(MsUnLock())

		nRec := P50->(RECNO())

		//Devolução Mês fechado
	ElseIf cOper == "I" .And. nOperac == 4

		cFilInt := aXml[1]:CFILIALDOC
		cNumNf  := aXml[1]:CDOC
		cSerNf  := aXml[1]:CSERIE
		cFornNF := aXml[1]:CFORNECEDOR
		cLojFrn := aXml[1]:CLOJA
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_OPER   := "Devolução de mês fechado"
		P50->(MsUnLock())

		nRec := P50->(RECNO())

		//Cancelamento devolução de mês fechado
	ElseIf cOper == "I" .And. nOperac == 6

		cFilInt := aXml[1]:CFILIALDOC
		cNumNf  := aXml[1]:CDOC
		cSerNf  := aXml[1]:CSERIE
		cFornNF := aXml[1]:CFORNECEDOR
		cLojFrn := aXml[1]:CLOJA
		cIProc  := Dtos(date()) + " " + Time()
		cJson   := FwJsonSerialize(aXml)

		DbSelectArea("P50")
		Reclock("P50",.T.)
		P50->P50_FILIAL := cFilInt
		P50->P50_NUMNF  := cNumNF
		P50->P50_SERIE  := cSerNf
		P50->P50_FORNEC := cFornNF
		P50->P50_LOJA   := cLojFrn
		P50->P50_IPROC  := cIproc
		P50->P50_JSON   := cJson
		P50->P50_OPER   := "Cancelamento da devolução de mês fechado"
		P50->(MsUnLock())

		nRec := P50->(RECNO())

	ElseIf cOper == "A"
		DbSelectArea("P50")
		P50->(DbGoTo(nRec))

		Reclock("P50",.F.)

		P50->P50_FPROC := Dtos(date()) + " " + Time()
		P50->P50_STATUS := Iif(aInfo[2] == 1,"Ok","Erro")
		P50->P50_RET := aInfo[1]
		P50->P50_TEMPO := ElapTime( Right(AllTrim(P50->P50_IPROC),8), Right(AllTrim(P50->P50_FPROC),8))

		P50->(MsUnLock())
	EndIf

	RestArea(aArea)
Return nRec

//-------------------------------------------------------------------
/*/{Protheus.doc} FCADP50()
Tela de visualização do LOG P50
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function FCADP50()

	Local oBrowse := FWmBrowse():New()

	Private cNomeLog  := "Log de integrações NF"

	oBrowse:AddLegend("P50_STATUS=='Ok   '", "ENABLE" , "Integrado com sucesso!" )
	oBrowse:AddLegend("P50_STATUS=='Erro '", "DISABLE" , "Erro na integração!"  )
	oBrowse:AddLegend("P50_STATUS=='     '", "BR_AZUL"  , "Integração em andamento!" )

	oBrowse:SetAlias("P50")
	oBrowse:SetMenuDef("MSINTNFS")
	oBrowse:SetDescription("Log de integrações de NFS")
	oBrowse:Activate()

Return NIL

//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef()
Construção do menu na rotina FCADP50
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
Static Function MenuDef()
	Local aRotina := {}
	Local aFuncoes := {}
	Local aRels := {}
	Local aEscolha := {}

	ADD OPTION aRotina TITLE "Visualizar" ACTION "VIEWDEF.MSINTNFS" OPERATION 2  ACCESS 0 // Visualizar
	ADD OPTION aRotina TITLE "Funções/Relatórios" ACTION aEscolha OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aEscolha TITLE "Funções" ACTION aFuncoes OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aEscolha TITLE "Relatórios" ACTION aRels OPERATION 4  ACCESS 0 // Visualizar
	//Funções
	ADD OPTION aFuncoes TITLE "Tempo médio de integração" ACTION 'Processa({||U_MSINTNFA()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aFuncoes TITLE "Status NF P12" ACTION 'Processa({||U_MSINTNFB()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aFuncoes TITLE "Visualizar documento emitido - Nota" ACTION 'Processa({||U_MSINTNFC()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aFuncoes TITLE "Visualizar documento emitido - Título" ACTION 'Processa({||U_MSINTNFD()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar




	//Relatórios
	ADD OPTION aRels TITLE "Relatório de integrações - Resumido"    ACTION 'Processa({||U_MSINTNFE()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aRels TITLE "Relatório de duplicidade na integração" ACTION 'Processa({||U_MSINTNFG()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar
	ADD OPTION aRels TITLE "Relatório do quantitativo de ingrações por período" ACTION 	'Processa({|| U_MSINTNFH()}, "Log de integrações - NF")' OPERATION 4  ACCESS 0 // Visualizar



Return aRotina

//-------------------------------------------------------------------
/*/{Protheus.doc} ModelDef()
Construção do modelo na rotina de LOG P50
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
Static Function ModelDef()

	Local oStru := FwFormStruct(1, "P50")


	oModel := MPFormModel():New('MXCADP50',,,)
	oModel:AddFields('P50MASTER', , oStru, , , )
	oModel:SetDescription('Log de integrações de NFS')
	oModel:GetModel('P50MASTER'):SetDescription('Log de integrações de NFS')
	oModel:GetModel("P50MASTER"):SetPrimaryKey({"P50_FILIAL", "P50_NUMNF", "P50_SERIE","P50_FORNEC","P50_LOJA"})

Return oModel

//-------------------------------------------------------------------
/*/{Protheus.doc} ModelDef()
Construção da view na rotina de LOG P50
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
Static Function ViewDef()

	Local oModel   	:= FWLoadModel('MSINTNFS')
	Local oStru 	:= FwFormStruct(2, "P50")
	Local oView		:= Nil

	oView := FWFormView():New()

	oView:SetModel(oModel)
	oView:AddField('VIEW_P50', oStru, 'P50MASTER')
	oView:CreateHorizontalBox('TELA' , 100)
	oView:SetOwnerView('VIEW_P50', 'TELA')

Return oView


//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFB()
Rotina para verificar situação do título no P12
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFB()

	Local aArea := GetArea()
	Local cRet := ""
	DbSelectArea("SE2")
	SE2->(DbSetOrder(1))

	If SE2->(DbSeek(P50->(P50_FILIAL+P50_SERIE+P50_NUMNF+P50_PARCEL+P50_TIPO+P50_FORNEC+P50_LOJA)))

		IF !Empty(SE2->E2_BAIXA)
			cRet := "Titulo Baixado."
		ElseIf !Empty(SE2->E2_NUMBOR)
			cRet := "Titulo em borderô."
		Else
			cRet := "Titulo em aberto."
		EndIf
	Else
		cRet := "Titulo excluído."
	EndIf

	FWAlertInfo(cRet,cNomeLog)
	RestArea(aArea)
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} fGetOper()
Rotina para verificar se o título é inclusão ou operação na hora de gravar no LOG
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
Static Function fGetOper(cChave)

	Local aArea := GetArea()
	Local cRet := ""

	DbSelectArea("SE2")
	SE2->(DbSetOrder(1))

	If SE2->(DbSeek(cChave))
		cRet := "Alteração"
	Else
		cRet := "Inclusão"
	EndIf

	RestArea(aArea)
Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFA()
Rotina do menu para verificar o tempo de integração em um determinado range de data.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFA()


	Local cQry := ""
	Local cAliasT := GetNextAlias()
	Local cTempo := ""
	Local aPergs   := {}
	Local dDataDe  := Date()
	Local cData   := ""




	aAdd(aPergs, {1, "Data",  dDataDe,  "", ".T.", "", ".T.", 80,  .F.})


	If ParamBox(aPergs, "Informe a data desejada")

		If Empty(MV_PAR01)
			Return
		EndIf
		dDataDe := MV_PAR01
		cData := DtoS(dDataDe)
		cQry += " SELECT AVG(TO_NUMBER(SUBSTR(P50_TEMPO, 1, 2))*3600 + TO_NUMBER(SUBSTR(P50_TEMPO, 4, 2))*60 + TO_NUMBER(SUBSTR(P50_TEMPO, 7, 2))) AS T, COUNT(*) AS TOTAL FROM "
		cQry += RETSQLNAME("P50")
		cQry += " WHERE D_E_L_E_T_ = ' ' "
		cQry += " AND P50_IPROC >= '"+cData+ " 00:00:00' "
		cQry += " AND P50_FPROC <= '"+cData+ " 23:59:59' "
		cQry += " AND P50_TEMPO <> ' ' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasT,.T.,.T.)

		If !(cAliasT)->(EOF())
			cTempo := "O tempo médio de integração é de " +cVALTOCHAR(ROUND((cALIAST)->T,2)) + " segundos. " + CRLF
			ctempo += "Para " + cValToChar((cAliasT)->TOTAL) + " nota(s) integrada(s)."
			FWAlertInfo(cTempo,cNomeLog)
		Else
			FWAlertInfo("Ainda não existem documentos integrados na data selecionada.",cNomeLog)
		EndIf
	EndIf
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFC()
Rotina do menu para exibir o documento selecionado na tela, como se estivesse visualizando no documento de entrada.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFC()

	Private aRotina := {}

	DbSelectArea("SF1")
	SF1->(DbSetOrder(1))

	If SF1->(DBSEEK(P50->(P50_FILIAL+P50_NUMNF+P50_SERIE+P50_FORNEC+P50_LOJA)))
		aAdd(aRotina,{OemToAnsi("Pesquisar"), "AxPesqui"   , 0 , 1, 0, .F.}) 		//"Pesquisar"
		aAdd(aRotina,{OemToAnsi("Visualizar"), "A103NFiscal", 0 , 2, 0, nil}) 		//"Visualizar"
		aAdd(aRotina,{OemToAnsi("Incluir"), "A103NFiscal", 0 , 3, 0, nil}) 		//"Incluir"
		aAdd(aRotina,{OemToAnsi("Classificar"), "A103NFiscal", 0 , 4, 0, nil}) 		//"Classificar"
		aAdd(aRotina,{OemToAnsi("Excluir"), "A103NFiscal", 3 , 5, 0, nil})		//"Excluir"
		A103NFiscal("SF1",SF1->(RecNo()),2)
	else
		FWAlertInfo("A nota não está cadastrada no sistema.",cNomeLog)
	EndIf
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFD()
Rotina do menu para exibir o documento selecionado na tela, como se estivesse visualizando no contas a pagar.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFD()

	Local cAlias := "SE2"

	DbSelectArea("SE2")
	SE2->(DbSetOrder(1))

	If SE2->(DbSeek(P50->(P50_FILIAL+P50_SERIE+P50_NUMNF+P50_PARCEL+P50_TIPO+P50_FORNEC+P50_LOJA)))
		xFa050Vis( cAlias, SE2->(RECNO()),2)
	else
		FWAlertInfo("A nota não está cadastrada no sistema.",cNomeLog)
	EndIf
Return




Static Function xFa050Vis( cAlias As Character, nReg As Numeric, nOpc As Numeric,aRotAuto As Array, nOpcion As Numeric, nOpcAuto As Numeric, bExecuta As Block, aDadosBco As Array, lExibeLanc As Logical,;
		lOnline As Logical, aDadosCTB As Array, aTitPrv As Array, lMsBlQl As Logical, lPaMovBco As Logical, aVAAutP As Array, cUUIDBS As Character )

	Local aBut050  As Array
	LOCAL nOpcA    As Numeric
	Local lF050VIS As Logical

	PRIVATE aRatAFR		As Array
	Private aSE2FI2		As Array
	Private aCposAlter  As Array
	PRIVATE bPMSDlgFI	As Block
	PRIVATE _Opc 		As Numeric

	PRIVATE cCadastro 	:= STR0007 // "Contas a Pagar"
	PRIVATE cBancoAdt	:= CriaVar("A6_COD")
	PRIVATE cAgenciaAdt	:= CriaVar("A6_AGENCIA")
	PRIVATE cNumCon	 	:= CriaVar("A6_NUMCON")
	PRIVATE nMoedAdt	:= CriaVar("A6_MOEDA")
	PRIVATE cChequeAdt	:= CriaVar("EF_NUM")
	PRIVATE cHistor		:= CriaVar("EF_HIST")
	PRIVATE cBenef		:= CriaVar("EF_BENEF")
	PRIVATE lAltera		:= .F.
	PRIVATE nMoeda 		:= Int(Val(GetMv("MV_MCUSTO")))
	If Type("lWserver") == "U"
		PRIVATE cMarca 		:= GetMark( )
	EndIf
	PRIVATE aTELA[0][0]
	PRIVATE aGETS[0]
	PRIVATE cPictHist   := ""
	PRIVATE lVerifyBlq  := .F.
	PRIVATE cLote       := ""
	PRIVATE nQtdTot     := 0		//Utilizado no Rateio Externo do SIGACTB.
	PRIVATE aItensCTB   := Iif(aDadosCTB <> Nil, aDadosCTB, {})
	PRIVATE aItnTitPrv  := Iif(aTitPrv   <> Nil, aTitPrv  , {})
	PRIVATE cItnUuidBs  := Iif(cPaisLoc = "RUS" .AND. CUUIDBS <> Nil, cUUIDBS, "") //cItnUuidBs - UUID Bank statment insinde FINA050
	PRIVATE __LLOCBRA   := .T.
	DEFAULT aDadosBco   := {}
	DEFAULT lMsBlQl     := .T.
	DEFAULT lPaMovBco	:= .T.
	DEFAULT cUUIDBS	    := ""

	Default __lIntPFS  := SuperGetMv("MV_JURXFIN",.T.,.F.) //Integração do Financeiro com o Juridico(Habilitado = .T.)
	Default __lTemMR   := (FindFunction("FTemMotor") .and. FTemMotor())

	nOpcA    := 0
	aBut050  := {}
	lF050VIS := Existblock("F050VIS")

	aRatAFR		:= {}
	bPMSDlgFI	:= {||PmsDlgFI(2,M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,M->E2_FORNECE,M->E2_LOJA)}
	_Opc 		:= nOpc
	aSE2FI2		:=	{} // Utilizada para gravacao das justificativas
	aCposAlter  :=  {}

	dbSelectArea("SA2")
	dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA)

	//Botoes adicionais na EnchoiceBar
	aBut050 := fa050BAR('SE2->E2_PROJPMS == "1"')

	///Projeto
	//inclusao do botao Posicao
	AADD(aBut050, {"HISTORIC", {|| Fc050Con() }, STR0204}) //"Posicao"

	//inclusao do botao Rastreamento
	AADD(aBut050, {"HISTORIC", {|| Fin250Pag(2) }, STR0205}) //"Rastreamento"

	If __lIntPFS .And. FindFunction("JURA246") .And. !(SE2->E2_TIPO $ MVTAXA+"|"+MVINSS+"|"+MVISS+"|"+MVTXA+"|SES|INA|IRF|PIS|COF|CSL")
		Aadd(aBut050,{"", {|| JURA246(1) }, STR0296}) //"Detalhe / Desdobramentos" (Módulo SIGAPFS)
	EndIF

	//Motor de retenções
	If __lTemMR
		AADD(aBut050, {"HISTORIC", {|| FINCRET('SE2') }, STR0300}) //'Consulta de Retenções'
	EndIF

	// integração com o PMS
	If IntePMS() .And. SE2->E2_PROJPMS == "1"
		SetKey(VK_F10, {|| Eval(bPMSDlgFI)})
	EndIf
	dbSelectArea(cAlias)
	//RegToMemory("SE2",.T.,,.F.,FunName())
	nOpca := AxVisual(cAlias,nReg,nOpc,,4,SA2->A2_NOME,"FA050MCPOS",aBut050)
	If lF050VIS		// ponto na saida da visualizacao
		Execblock("F050VIS",.f.,.f.)
	Endif

	If IntePMS() .And. SE2->E2_PROJPMS == "1"
		SetKey(VK_F10, Nil)
	EndIf
	If __lLocBRA
		F986LimpaVar() //Limpa as variaveis estaticas - Complemento de Titulo
	EndIf

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFE()
Rotina do menu para exibir o relatório de integrações resumido
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFE()

	Local aArea        := GetArea()
	Local oFWMsExcel
	Local oExcel
	Local cArquivo    := GetTempPath()+'RELNF'+DTOS(DATE())+'.xml'
	Local cQry := ""
	Local cAliasRel := GetNextAlias()
	Local aPergs   := {}
	Local dDataDe  := Date()
	Local dDataAt  := Date()
	Local cFilRelI    := Space(08)
	Local cNfRelI     := Space(09)
	Local cSerieRelI  := Space(03)
	Local cFornRelI := Space(06)
	Local cLojaRelI   := Space(02)
	Local cFilRelF    := Space(08)
	Local cNfRelF     := Space(09)
	Local cSerieRelF  := Space(03)
	Local cFornRelF := Space(06)
	Local cLojaRelF   := Space(02)
	Local cDataI      := ""
	Local cDataF      := ""


	aAdd(aPergs, {1, "Data De",  dDataDe,  "", ".T.", "", ".T.", 80,  .F.})
	aAdd(aPergs, {1, "Data Até", dDataAt,  "", ".T.", "", ".T.", 80,  .F.})

	aAdd(aPergs, {1, "Filial De",  cFilRelI,  "", ".T.", "SM0", ".T.", 80,  .F.})
	aAdd(aPergs, {1, "Filial Até", cFilRelF,  "", ".T.", "SM0", ".T.", 80,  .F.})

	aAdd(aPergs, {1, "Num Nf De",     cNfRelI, "", ".T.", "",    ".T.", 80, .F.})
	aAdd(aPergs, {1, "Num Nf Até",     cNfRelF, "", ".T.", "",    ".T.", 80, .F.})

	aAdd(aPergs, {1, "Da Série",     cSerieRelI, "", ".T.", "",    ".T.", 80, .F.})
	aAdd(aPergs, {1, "Até a Série",     cSerieRelF, "", ".T.", "",    ".T.", 80, .F.})

	aAdd(aPergs, {1, "Do Fornecedor",     cFornRelI, "", ".T.", "",    ".T.", 80, .F.})
	aAdd(aPergs, {1, "Até o Fornecedor",     cFornRelF, "", ".T.", "",    ".T.", 80, .F.})

	aAdd(aPergs, {1, "Da Loja",     cLojaRelI, "", ".T.", "",    ".T.", 80, .F.})
	aAdd(aPergs, {1, "Até a Loja",     cLojaRelF, "", ".T.", "",    ".T.", 80, .F.})

	If ParamBox(aPergs, "Informe os parâmetros")

		If (Empty(MV_PAR01) .Or. Empty(MV_PAR02))
			FwAlertError("Os parâmetros de data são obrigatórios!!",cNomeLog)
			Return
		EndIf

		cFilRelI    := MV_PAR03
		cNfRelI     := MV_PAR05
		cSerieRelI  := MV_PAR07
		cFornRelI := MV_PAR09
		cLojaRelI   := MV_PAR11
		cFilRelF    := MV_PAR04
		cNfRelF     := MV_PAR06
		cSerieRelF  := MV_PAR08
		cFornRelF := MV_PAR10
		cLojaRelF   := MV_PAR12
		cDataI      := DtoS(MV_PAR01)
		cDataF      := DtoS(MV_PAR02)


		cQry += " WITH Recentes AS ( "
		cQry += " SELECT "
		cQry += " P50_FILIAL, "
		cQry += " P50_NUMNF, "
		cQry += " P50_SERIE, "
		cQry += " P50_FORNEC, "
		cQry += " P50_LOJA, "
		cQry += " MAX(R_E_C_N_O_) AS Max_RECNO "
		cQry += " FROM "
		cQry += RetSqlName("P50")
		cQry += " WHERE
		cQry += " D_E_L_E_T_ = ' ' AND P50_FPROC BETWEEN '"+cDataI+ " 00:00:00' AND '"+cDataF+" 23:59:59'
		cQry += " GROUP BY "
		cQry += " P50_FILIAL, "
		cQry += " P50_NUMNF, "
		cQry += " P50_SERIE, "
		cQry += " P50_FORNEC, "
		cQry += " P50_LOJA) "

		cQry += " SELECT P.P50_FILIAL, P.P50_NUMNF, P.P50_SERIE, P.P50_FORNEC, P.P50_LOJA, COUNT(*) AS TOTAL, "
		cQry += " MAX(P.P50_OPER) KEEP (DENSE_RANK LAST ORDER BY P.R_E_C_N_O_) AS RECENTE, "
		cQry += " MAX(P.P50_FPROC) KEEP (DENSE_RANK LAST ORDER BY P.R_E_C_N_O_) AS DATAF, "
		cQry += " MAX(P.P50_STATUS) KEEP (DENSE_RANK LAST ORDER BY P.R_E_C_N_O_) AS STATUS FROM "
		cQry += RetSqlName("P50") + " P "
		cQry += " JOIN Recentes R ON P.P50_FILIAL = R.P50_FILIAL "
		cQry += " AND P.P50_NUMNF = R.P50_NUMNF "
		cQry += " AND P.P50_SERIE = R.P50_SERIE "
		cQry += " AND P.P50_FORNEC = R.P50_FORNEC "
		cQry += " AND P.P50_LOJA = R.P50_LOJA "
		cQry += " WHERE P.D_E_L_E_T_ = ' ' AND P.P50_FPROC BETWEEN '"+cDataI+ " 00:00:00' AND '"+cDataF+" 23:59:59'"

		cQry += " AND P.P50_FILIAL BETWEEN '"+cFilRelI+"' AND '"+cFilRelF+"'"
		cQry += " AND P.P50_NUMNF  BETWEEN '"+cNfRelI+"' AND '"+cNfRelF+"'"
		cQry += " AND P.P50_SERIE  BETWEEN '"+cSerieRelI+"' AND '"+cSerieRelF+"'"
		cQry += " AND P.P50_FORNEC BETWEEN '"+cFornRelI+"' AND '"+cFornRelF+"'"
		cQry += " AND P.P50_LOJA   BETWEEN '"+cLojaRelI+"' AND '"+cLojaRelF+"'"
		cQry += " GROUP BY P.P50_FILIAL, P.P50_NUMNF, P.P50_SERIE, P.P50_FORNEC, P.P50_LOJA "



		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasRel,.T.,.T.)

		If !(cAliasRel)->(EOF())
			//Criando o objeto que irá gerar o conteúdo do Excel
			oFWMsExcel := FWMSExcel():New()



			oFWMsExcel:AddworkSheet("Relatório de NFS resumido")
			//Criando a Tabela
			oFWMsExcel:AddTable("Relatório de NFS resumido","Notas Fiscais")
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Filial",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Número da NF",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Série da NF",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Fornecedor",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Loja",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Quantidade de integrações",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Ultima operação",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Data da última operação",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Status da última operação",1)
			//Criando as Linhas... Enquanto não for fim da query
			(cAliasRel)->(DbGoTop())
			While !((cAliasRel)->(EoF()))
				oFWMsExcel:AddRow("Relatório de NFS resumido","Notas Fiscais",{;
					(cAliasRel)->P50_FILIAL,;
					(cAliasRel)->P50_NUMNF,;
					(cAliasRel)->P50_SERIE,;
					(cAliasRel)->P50_FORNEC,;
					(cAliasRel)->P50_LOJA,;
					(cAliasRel)->TOTAL,;
					(cAliasRel)->RECENTE,;
					(cAliasRel)->DATAF,;
					(cAliasRel)->STATUS;
					})

				//Pulando Registro
				(cAliasRel)->(DbSkip())
			EndDo

			//Ativando o arquivo e gerando o xml
			oFWMsExcel:Activate()
			oFWMsExcel:GetXMLFile(cArquivo)

			//Abrindo o excel e abrindo o arquivo xml
			oExcel := MsExcel():New()             //Abre uma nova conexão com Excel
			oExcel:WorkBooks:Open(cArquivo)     //Abre uma planilha
			oExcel:SetVisible(.T.)                 //Visualiza a planilha
			oExcel:Destroy()                        //Encerra o processo do gerenciador de tarefas

		Else
			FWAlertInfo("Ainda não existem documentos integrados na data selecionada.",cNomeLog)
		EndIf

	EndIf
	RestArea(aArea)
Return



//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFG()
Rotina do menu para exibir o relatório de notas integradas com duplicidade.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFG()

	Local aArea        := GetArea()
	Local oFWMsExcel
	Local oExcel
	Local cArquivo    := GetTempPath()+'RELDUPNF'+DTOS(DATE())+'.xml'
	Local cQry := ""
	Local cAliasRel := GetNextAlias()
	Local aPergs   := {}
	Local dDataDe  := Date()
	Local dDataAt  := Date()
	Local cDataI      := ""
	Local cDataF      := ""
	Local nX 		  := 0
	Local cChave 	  := ""
	Local cParte 	  := ""


	aAdd(aPergs, {1, "Data De",  dDataDe,  "", ".T.", "", ".T.", 80,  .F.})
	aAdd(aPergs, {1, "Data Até", dDataAt,  "", ".T.", "", ".T.", 80,  .F.})

	If ParamBox(aPergs, "Informe os parâmetros")

		If (Empty(MV_PAR01) .Or. Empty(MV_PAR02))
			FWAlertError("Os parâmetros de data são obrigatórios!!",cNomeLog)
			Return
		EndIf

		cDataI      := DtoS(MV_PAR01)
		cDataF      := DtoS(MV_PAR02)


		cQry += " SELECT P50_FILIAL, P50_NUMNF, P50_SERIE, P50_FORNEC, P50_LOJA, COUNT(*) AS QTD_ENVIOS "
		cQry += " ,PARTE1, PARTE2, PARTE3, PARTE4,PARTE5,PARTE6,PARTE7,PARTE8,PARTE9,PARTE10,PARTE11,PARTE12 "
		cQry += " FROM "
		cQry += " (SELECT P50_FILIAL, P50_NUMNF, P50_SERIE, P50_FORNEC, P50_LOJA,P50_OPER, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 1, 1000) AS VARCHAR2(1000))  AS parte1, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 1001, 1000) AS VARCHAR2(1000)) AS parte2, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 2001, 1000) AS VARCHAR2(1000)) AS parte3, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 3001, 1000) AS VARCHAR2(1000)) parte4, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 4001, 1000) AS VARCHAR2(1000)) parte5, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 5001, 1000) AS VARCHAR2(1000)) parte6, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 6001, 1000) AS VARCHAR2(1000)) parte7, "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 7001, 1000) AS VARCHAR2(1000)) parte8,  "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 8001, 1000) AS VARCHAR2(1000)) parte9 , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 9001, 1000) AS VARCHAR2(1000)) parte10  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 10001, 1000) AS VARCHAR2(1000)) parte11  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 11001, 1000) AS VARCHAR2(1000)) parte12,  "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 12001, 1000) AS VARCHAR2(1000)) parte13  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 13001, 1000) AS VARCHAR2(1000)) parte14  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 14001, 1000) AS VARCHAR2(1000)) parte15  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 15001, 1000) AS VARCHAR2(1000)) parte16  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 16001, 1000) AS VARCHAR2(1000)) parte17  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 17001, 1000) AS VARCHAR2(1000)) parte18  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 18001, 1000) AS VARCHAR2(1000)) parte19  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 19001, 1000) AS VARCHAR2(1000)) parte20  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 20001, 1000) AS VARCHAR2(1000)) parte21  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 21001, 1000) AS VARCHAR2(1000)) parte22  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 22001, 1000) AS VARCHAR2(1000)) parte23  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 23001, 1000) AS VARCHAR2(1000)) parte24  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 24001, 1000) AS VARCHAR2(1000)) parte25  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 25001, 1000) AS VARCHAR2(1000)) parte26  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 26001, 1000) AS VARCHAR2(1000)) parte27  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 27001, 1000) AS VARCHAR2(1000)) parte28  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 28001, 1000) AS VARCHAR2(1000)) parte29  , "
		cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 29001, 1000) AS VARCHAR2(1000)) parte30   "
		cQry += " FROM " + RetSqlName("P50") + " P50 "
		cQry += " WHERE P50.D_E_L_E_T_ = ' ' "
		cQry += " AND P50.P50_STATUS = 'Ok' "
		cQry += " AND P50.P50_IPROC >= '" +cDataI+ " 00:00:00' AND P50.P50_IPROC <= '"+cDataF+" 23:59:59')"
		cQry += " HAVING COUNT(*) > 1 "
		cQry += " GROUP BY P50_FILIAL, P50_NUMNF, P50_SERIE, P50_FORNEC, P50_LOJA, PARTE1, PARTE2, PARTE3, PARTE4,PARTE5,PARTE6,PARTE7,PARTE8,PARTE9,PARTE10,PARTE11,PARTE12,PARTE13,PARTE14,PARTE15,PARTE16,PARTE17,PARTE18,PARTE19,PARTE20,PARTE21,PARTE22,PARTE23,PARTE24,PARTE25,PARTE26,PARTE27,PARTE28,PARTE29,PARTE30"
		cQry += " ORDER BY P50_FILIAL, P50_NUMNF, P50_SERIE, P50_FORNEC, P50_LOJA "



		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasRel,.T.,.T.)

		If !(cAliasRel)->(EOF())
			//Criando o objeto que irá gerar o conteúdo do Excel
			oFWMsExcel := FWMSExcel():New()



			oFWMsExcel:AddworkSheet("Relatório de NFS resumido")
			//Criando a Tabela
			oFWMsExcel:AddTable("Relatório de NFS resumido","Notas Fiscais")
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Filial",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Número da NF",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Série da NF",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Fornecedor",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Loja",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Quantidade de envios",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Informação sobre envios",1)
			oFWMsExcel:AddColumn("Relatório de NFS resumido","Notas Fiscais","Json",1)
			//Criando as Linhas... Enquanto não for fim da query
			(cAliasRel)->(DbGoTop())
			While !((cAliasRel)->(EoF()))

				For nX := 1 To 12
					cParte := "PARTE"+cValToChar(nX)
					cChave := cChave + cParte
				Next nX

				cChave := (cAliasRel)->(PARTE1+PARTE2+PARTE3+PARTE4+PARTE5+PARTE6+PARTE7+PARTE8+PARTE9+PARTE10+PARTE11+PARTE12)
				oFWMsExcel:AddRow("Relatório de NFS resumido","Notas Fiscais",{;
					(cAliasRel)->P50_FILIAL,;
					(cAliasRel)->P50_NUMNF,;
					(cAliasRel)->P50_SERIE,;
					(cAliasRel)->P50_FORNEC,;
					(cAliasRel)->P50_LOJA,;
					(cAliasRel)->QTD_ENVIOS,;
					fInfoEnvs(cChave,cDataI,cDataF,(cAliasRel)->(P50_FILIAL),(cAliasRel)->(P50_NUMNF),(cAliasRel)->(P50_SERIE),(cAliasRel)->(P50_FORNEC),(cAliasRel)->(P50_LOJA)),;
					cChave;
					})

				//Pulando Registro
				(cAliasRel)->(DbSkip())
			EndDo

			//Ativando o arquivo e gerando o xml
			oFWMsExcel:Activate()
			oFWMsExcel:GetXMLFile(cArquivo)

			//Abrindo o excel e abrindo o arquivo xml
			oExcel := MsExcel():New()             //Abre uma nova conexão com Excel
			oExcel:WorkBooks:Open(cArquivo)     //Abre uma planilha
			oExcel:SetVisible(.T.)                 //Visualiza a planilha
			oExcel:Destroy()                        //Encerra o processo do gerenciador de tarefas

		Else
			FWAlertInfo("Não existem integrações com duplicidade no período selecionado.",cNomeLog)
		EndIf

	EndIf
	RestArea(aArea)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fInfoEnvs()
Rotina do menu para exibir o relatório de notas integradas com duplicidade.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
Static Function fInfoEnvs(cChave,cDataI,cDataF,cFil,cNf,cSerie,cFornec,cLoja)


	Local cQry := ""
	Local cTabTemp := GetNextAlias()
	Local cRet := ""

	Default cChave := ""
	Default cDataI := ""
	Default cDataF := ""



	cQry += " SELECT  "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 1, 1000) AS VARCHAR2(1000))  AS parte1, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 1001, 1000) AS VARCHAR2(1000)) AS parte2, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 2001, 1000) AS VARCHAR2(1000)) AS parte3, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 3001, 1000) AS VARCHAR2(1000)) parte4, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 4001, 1000) AS VARCHAR2(1000)) parte5, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 5001, 1000) AS VARCHAR2(1000)) parte6, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 6001, 1000) AS VARCHAR2(1000)) parte7, "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 7001, 1000) AS VARCHAR2(1000)) parte8,  "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 8001, 1000) AS VARCHAR2(1000)) parte9 , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 9001, 1000) AS VARCHAR2(1000)) parte10  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 10001, 1000) AS VARCHAR2(1000)) parte11  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 11001, 1000) AS VARCHAR2(1000)) parte12,  "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 12001, 1000) AS VARCHAR2(1000)) parte13  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 13001, 1000) AS VARCHAR2(1000)) parte14  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 14001, 1000) AS VARCHAR2(1000)) parte15  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 15001, 1000) AS VARCHAR2(1000)) parte16  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 16001, 1000) AS VARCHAR2(1000)) parte17  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 17001, 1000) AS VARCHAR2(1000)) parte18  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 18001, 1000) AS VARCHAR2(1000)) parte19  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 19001, 1000) AS VARCHAR2(1000)) parte20  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 20001, 1000) AS VARCHAR2(1000)) parte21  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 21001, 1000) AS VARCHAR2(1000)) parte22  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 22001, 1000) AS VARCHAR2(1000)) parte23  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 23001, 1000) AS VARCHAR2(1000)) parte24  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 24001, 1000) AS VARCHAR2(1000)) parte25  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 25001, 1000) AS VARCHAR2(1000)) parte26  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 26001, 1000) AS VARCHAR2(1000)) parte27  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 27001, 1000) AS VARCHAR2(1000)) parte28  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 28001, 1000) AS VARCHAR2(1000)) parte29  , "
	cQry += " CAST(SUBSTR(BLOB2CHAR(P50_JSON), 29001, 1000) AS VARCHAR2(1000)) parte30,   "
	cQry += "  ROW_NUMBER() OVER (ORDER BY P50.P50_IPROC) AS LINHA, R_E_C_N_O_ AS RECNO, P50.* FROM "+RetSqlName("P50")+ " P50 " + CRLF
	cQry += " WHERE P50.D_E_L_E_T_ = ' ' " + CRLF
	cQry += " AND P50.P50_STATUS = 'Ok' " + CRLF
	cQry += " AND P50.P50_IPROC >= '" +cDataI+ " 00:00:00' AND P50.P50_IPROC <= '"+cDataF+" 23:59:59'" + CRLF
	cQry += " AND P50.P50_FILIAL = '" +cFil+ " '"
	cQry += " AND P50.P50_NUMNF = '" +cNF+ " '"
	cQry += " AND P50.P50_SERIE = '" +cSerie+ " '"
	cQry += " AND P50.P50_FORNEC = '" +cFornec+ " '"
	cQry += " AND P50.P50_LOJA = '" +cLoja+ " '"
	cQry += " ORDER BY P50_IPROC "

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cTabTemp,.T.,.T.)

	While !((cTabTemp)->(EoF()))

		If AllTrim((cTabTemp)->(PARTE1+PARTE2+PARTE3+PARTE4+PARTE5+PARTE6+PARTE7+PARTE8+PARTE9+PARTE10+PARTE11+PARTE12+PARTE13+PARTE14+PARTE15+PARTE16+PARTE17+PARTE18+PARTE19+PARTE20+PARTE21+PARTE22+PARTE23+PARTE24+PARTE25+PARTE26+PARTE27+PARTE28+PARTE29+PARTE30)) == Alltrim(cChave)
			cRet += cValToChar((cTabTemp)->LINHA) + "º envio - Data/Hora: "+(cTabTemp)->P50_IPROC+ " - Tempo de integração: "+(cTabTemp)->P50_TEMPO+ " Operação: "+(cTabTemp)->P50_OPER+ " RECNO na tabela de LOG: "+ cValToChar((cTabTemp)->RECNO) + " |"
		EndIf
		(cTabTemp)->(DbSkip())
	EndDo


Return cRet



//-------------------------------------------------------------------
/*/{Protheus.doc} MSINTNFH()
Rotina do menu para exibir o relatório com o quantitativo de integrações no período selecionado.
@author Lucas Miranda de Aguiar
@since 07/05/2025
@version 1.0
Inicial
@return NIL
/*/
//-------------------------------------------------------------------
User Function MSINTNFH()

	Local aArea        := GetArea()
	Local oFWMsExcel
	Local oExcel
	Local cArquivo    := GetTempPath()+'RELQTINT'+DTOS(DATE())+'.xml'
	Local cQry := ""
	Local cAliasRel := GetNextAlias()
	Local aPergs   := {}
	Local dDataDe  := Date()
	Local dDataAt  := Date()
	Local cDataI      := ""
	Local cDataF      := ""
	Local lFLine      := .T.


	aAdd(aPergs, {1, "Data De",  dDataDe,  "", ".T.", "", ".T.", 80,  .F.})
	aAdd(aPergs, {1, "Data Até", dDataAt,  "", ".T.", "", ".T.", 80,  .F.})

	If ParamBox(aPergs, "Informe os parâmetros")

		If (Empty(MV_PAR01) .Or. Empty(MV_PAR02))
			FwAlertError("Os parâmetros de data são obrigatórios!!",cNomeLog)
			Return
		EndIf

		cDataI      := DtoS(MV_PAR01)
		cDataF      := DtoS(MV_PAR02)


		cQry += " SELECT F1_FILIAL, COUNT(1) AS TOTAL_FILIAL, SUM(COUNT(1)) OVER () AS TOTAL_MES FROM "
		cQry += RetSqlName("SF1")
		cQry += " WHERE F1_DTDIGIT >= '"
		cQry += cDataI
		cQry += "' AND F1_DTDIGIT <= '"
		cQry += cDataF
		cQry += "' AND D_E_L_E_T_ = ' ' AND F1_XID <> ' ' "
		cQry += " GROUP BY F1_FILIAL "


		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasRel,.T.,.T.)

		If !(cAliasRel)->(EOF())
			//Criando o objeto que irá gerar o conteúdo do Excel
			oFWMsExcel := FWMSExcel():New()



			oFWMsExcel:AddworkSheet("Quantidade de NFS integradas por período")
			//Criando a Tabela
			oFWMsExcel:AddTable("Quantidade de NFS integradas por período","Notas Fiscais")
			oFWMsExcel:AddColumn("Quantidade de NFS integradas por período","Notas Fiscais","Filial",1)
			oFWMsExcel:AddColumn("Quantidade de NFS integradas por período","Notas Fiscais","Total da filial",1)
			oFWMsExcel:AddColumn("Quantidade de NFS integradas por período","Notas Fiscais","Soma total do período",1)

			//Criando as Linhas... Enquanto não for fim da query
			(cAliasRel)->(DbGoTop())
			While !((cAliasRel)->(EoF()))

				If lFLine
					oFWMsExcel:AddRow("Quantidade de NFS integradas por período","Notas Fiscais",{;
						(cAliasRel)->F1_FILIAL,;
						(cAliasRel)->TOTAL_FILIAL,;
						(cAliasRel)->TOTAL_MES;
						})
					lFline := .F.
				Else
					oFWMsExcel:AddRow("Quantidade de NFS integradas por período","Notas Fiscais",{;
						(cAliasRel)->F1_FILIAL,;
						(cAliasRel)->TOTAL_FILIAL,;
						' ';
						})
				EndIf
				//Pulando Registro
				(cAliasRel)->(DbSkip())
			EndDo

			//Ativando o arquivo e gerando o xml
			oFWMsExcel:Activate()
			oFWMsExcel:GetXMLFile(cArquivo)

			//Abrindo o excel e abrindo o arquivo xml
			oExcel := MsExcel():New()             //Abre uma nova conexão com Excel
			oExcel:WorkBooks:Open(cArquivo)     //Abre uma planilha
			oExcel:SetVisible(.T.)                 //Visualiza a planilha
			oExcel:Destroy()                        //Encerra o processo do gerenciador de tarefas

		Else
			FWAlertInfo("Não existem integrações no período selecionado.",cNomeLog)
		EndIf

	EndIf
	RestArea(aArea)
Return
